<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Angular路由懒加载配置</title>
    <link href="/2021/02/01/Angular%E8%B7%AF%E7%94%B1%E6%87%92%E5%8A%A0%E8%BD%BD%E9%85%8D%E7%BD%AE/"/>
    <url>/2021/02/01/Angular%E8%B7%AF%E7%94%B1%E6%87%92%E5%8A%A0%E8%BD%BD%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="NgModule的作用"><a href="#NgModule的作用" class="headerlink" title="@NgModule的作用"></a>@NgModule的作用</h1><ul><li>NgModule 最根本的意义是帮助开发者组织业务代码，开发者可以利用 NgModule 把关系比较紧密的组件组织到一起，这是首要的。</li><li>NgModule 用来控制组件、指令、管道等是否可以使用，处于同一个 NgModule 里面的组件默认互相可见，而对于外部的组件来说，只能看到 NgModule 导出（ exports ）的内容，也就是说，如果你定义的 NgModule 不 exports 任何内容，那么外部使用者即使 import 了你这个模块，也没法使用里面定义的任何内容。</li><li>NgModule 是打包时候用到的最小单位，打包的时候会检查所有 @NgModule 和路由配置，Angular底层是使用webpack打包。因为Angular已经帮我们配置好了webpack，所以开发者轻松很多，否则就需要自己配置环境。</li><li>NgModule 是 Router 进行异步加载的最小单位，Router 能加载的最小单位是模块，而不是组件。当然，模块里面只放一个组件是允许的，很多组件库都是这样做的。</li></ul><h1 id="NgModule结构说明"><a href="#NgModule结构说明" class="headerlink" title="@NgModule结构说明"></a>@NgModule结构说明</h1><pre><code class="hljs javascript">@NgModule(&#123;    providers: [], <span class="hljs-comment">//注入服务到当前模块</span>    declarations: [], <span class="hljs-comment">//属于当前模块的组件、指令及管道 (统称可声明对象)</span>    imports: [], <span class="hljs-comment">//当前模板所依赖的项，即外部模块（包括httpModule、路由等）　　</span>    <span class="hljs-keyword">export</span>:[],<span class="hljs-comment">//声明出应用给其他的module使用</span>    entryComponents: [],<span class="hljs-comment">//定义此NgModule中要编译的组件集，这样它们才可以动态加载到视图中(常用于动态加载组件)</span>    bootstrap: []<span class="hljs-comment">//默认启动哪个组件(只有根模块才能设置bootstrap属性)</span>&#125;)</code></pre><h1 id="懒加载说明"><a href="#懒加载说明" class="headerlink" title="懒加载说明"></a>懒加载说明</h1><p>（1）RouterModule对象提供了两个静态的方法:forRoot()和forChild()来配置路由信息。</p><ul><li>forRoot()//在主模块中定义主要的路由信息</li><li>forChild()//应用在特性模块（子模块）中</li></ul><p>（2）懒加载：loadChildren<br>此处并没有将对应的模块加入到AppModule中，而是通过loadChildren属性，告诉Angular路由依据loadChildren属性配置的路径去加载对应的模块。这就是模块懒加载功能的具体应用，当用户访问 /xxx/** 路径的时候，才会加载对应的模块，这减少了应用启动时加载资源的大小。 loadChildren的属性值由三部分组成：</p><ul><li>需要导入Module的相对路径</li><li>#分隔符</li><li>导出模块类的名称</li></ul><p>（3）预加载<br>在使用懒加载的情况下，路由第一次加载某个模块时，有时反应有延迟。这时就可以用预加载策略来解决这个问题。<br>Angular提供了两种加载策略，</p><ul><li>PreloadAllModules-预加载</li><li>NoPreloading-没有预加载（默认）。</li></ul><p>RouterModule.forRoo()的第二个参数可以添加配置选项，配置选项中就有一个是preloadingStrategy配置，这个配置是一个预加载策略配置。</p><pre><code class="hljs javascript"><span class="hljs-comment">//使用默认预加载-预加载全部模块</span><span class="hljs-keyword">import</span> &#123; NgModule &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core'</span>; <span class="hljs-keyword">import</span> &#123; AppComponent &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'./app.component'</span>; <span class="hljs-keyword">import</span> &#123; routes &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'./main.routing'</span>; <span class="hljs-keyword">import</span> &#123; RouterModule &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/router'</span>; <span class="hljs-keyword">import</span> &#123; PreloadAllModules &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/router'</span>; @NgModule(&#123; 　　    declarations: [AppComponent], 　　    imports: [ BrowserModule, RouterModule.forRoot(routes, &#123; <span class="hljs-attr">preloadingStrategy</span>: PreloadAllModules &#125;) ], 　　    providers: [], 　　    bootstrap: [AppComponent] &#125;) <span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppModule</span> </span>&#123; &#125;</code></pre><h1 id="自定义预加载策略"><a href="#自定义预加载策略" class="headerlink" title="自定义预加载策略"></a>自定义预加载策略</h1><ul><li><p>自定义5秒后加载所有模块<br>在app组件的同级新建一个custom-preloading-strategy.ts文件</p><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; Route &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/router'</span>;<span class="hljs-keyword">import</span> &#123; PreloadingStrategy &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/router'</span>;<span class="hljs-keyword">import</span> &#123; Observable &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'rxjs/Rx'</span>;<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomPreloadingStrategy</span> <span class="hljs-title">implements</span> <span class="hljs-title">PreloadingStrategy</span> </span>&#123;    preload(route: Route, <span class="hljs-attr">fn</span>: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> Observable&lt;boolean&gt;): Observable&lt;boolean&gt; &#123;        <span class="hljs-keyword">return</span> Observable.of(<span class="hljs-literal">true</span>).delay(<span class="hljs-number">5000</span>).flatMap(<span class="hljs-function">(<span class="hljs-params">_: boolean</span>) =&gt;</span> fn());    &#125;&#125;</code></pre><p>在app.modules.ts的providers中注入</p><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; BrowserModule &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/platform-browser'</span>;<span class="hljs-keyword">import</span> &#123; NgModule &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core'</span>;<span class="hljs-keyword">import</span> &#123; AppComponent &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'./app.component'</span>;<span class="hljs-keyword">import</span> &#123; HomeComponent &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'./home/home.component'</span>;<span class="hljs-keyword">import</span> &#123; routes &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'./main.routing'</span>;<span class="hljs-keyword">import</span> &#123; RouterModule &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/router'</span>;<span class="hljs-keyword">import</span> &#123; CustomPreloadingStrategy &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'./preload'</span>;@NgModule(&#123;    declarations: [        AppComponent,        HomeComponent    ],    imports: [        BrowserModule,        RouterModule.forRoot(routes, &#123; <span class="hljs-attr">preloadingStrategy</span>:  CustomPreloadingStrategy &#125;)    ],    providers: [CustomPreloadingStrategy ],    bootstrap: [AppComponent]&#125;)<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppModule</span> </span>&#123; &#125;</code></pre></li><li><p>自定义-指定模块预加载<br>在app组件的同级新建一个selective-preloading-strategy.ts文件<br>（需要在app-routing.module.ts中的providers注入，然后在路由中定义的data通过附加参数来设置是否预加载）</p><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; Injectable &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core'</span>;<span class="hljs-keyword">import</span> &#123; PreloadingStrategy, Route &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/router'</span>;<span class="hljs-keyword">import</span> &#123; Observable&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'rxjs/Observable'</span>;<span class="hljs-keyword">import</span> <span class="hljs-string">'rxjs/add/observable/of'</span>;@Injectable()<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SelectivePreloadingStrategy</span> <span class="hljs-title">implements</span> <span class="hljs-title">PreloadingStrategy</span> </span>&#123;    preloadedModules: string[] = [];    preload(route: Route, <span class="hljs-attr">load</span>: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> Observable&lt;any&gt;): Observable&lt;any&gt; &#123;        <span class="hljs-keyword">if</span> (route.data &amp;&amp; route.data[<span class="hljs-string">'preload'</span>]) &#123;        <span class="hljs-keyword">return</span> load();        &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">return</span> Observable.of(<span class="hljs-literal">null</span>);        &#125;    &#125;&#125;</code></pre><p>app-routing.module.ts（此文件懒加载与预加载相结合）</p><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; NgModule &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core'</span>;<span class="hljs-keyword">import</span> &#123; RouterModule, Routes &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/router'</span>;<span class="hljs-keyword">import</span> &#123; CanDeactivateGuard &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'./guard/can-deactivate-guard.service'</span>;<span class="hljs-keyword">import</span> &#123; SelectivePreloadingStrategy &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'./selective-preloading-strategy'</span>; <span class="hljs-comment">// 预加载</span><span class="hljs-keyword">import</span> &#123; PageNotFoundComponent &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'./not-found.component'</span>;<span class="hljs-keyword">const</span> appRoutes: Routes = [    &#123; <span class="hljs-attr">path</span>: <span class="hljs-string">''</span>, <span class="hljs-attr">redirectTo</span>: <span class="hljs-string">'home'</span>, <span class="hljs-attr">pathMatch</span>: <span class="hljs-string">'full'</span>&#125;,    &#123; <span class="hljs-attr">path</span>: <span class="hljs-string">'mian'</span>, <span class="hljs-attr">loadChildren</span>: <span class="hljs-string">'./main/mian.module#MainModule'</span> &#125;, <span class="hljs-comment">// 懒加载(在这个层级的router配置文件及module文件都不需要引入该组建)</span>    &#123; <span class="hljs-attr">path</span>: <span class="hljs-string">'home'</span>, <span class="hljs-attr">loadChildren</span>: <span class="hljs-string">'./home/home.module#HomeModule'</span>, <span class="hljs-attr">data</span>: &#123; <span class="hljs-attr">preload</span>: <span class="hljs-literal">true</span> &#125; &#125;, <span class="hljs-comment">// 懒加载 + 预加载</span>    &#123; <span class="hljs-attr">path</span>: <span class="hljs-string">'**'</span>, <span class="hljs-attr">component</span>: PageNotFoundComponent &#125; <span class="hljs-comment">// 注意要放到最后</span>];@NgModule(&#123;　　imports: [　　　　RouterModule.forRoot(appRoutes,&#123;　　　　　　enableTracing: <span class="hljs-literal">true</span>, <span class="hljs-comment">// &lt;-- debugging purposes only</span>　　　　　　preloadingStrategy: SelectivePreloadingStrategy <span class="hljs-comment">// 预加载</span>　　　　&#125;)　　],　　exports: [　　　　RouterModule　　],　　providers: [　　　　CanDeactivateGuard,　　　　SelectivePreloadingStrategy　　]&#125;)<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppRoutingModule</span> </span>&#123; &#125;</code></pre></li></ul>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Angular</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Angular ElementRef详解</title>
    <link href="/2020/11/11/Angular-ElementRef%E8%AF%A6%E8%A7%A3/"/>
    <url>/2020/11/11/Angular-ElementRef%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="一-为什么要用ElementRef"><a href="#一-为什么要用ElementRef" class="headerlink" title="一.为什么要用ElementRef"></a>一.为什么要用ElementRef</h1><p>为了能够支持跨平台，Angular 通过抽象层封装了不同平台的差异，统一了 API 接口。如定义了抽象类 Renderer（已废弃，现在用Renderer2） 、抽象类 RootRenderer 等。此外还定义了以下引用类型：</p><pre><code>1. ElementRef；2. TemplateRef；3. ViewRef ；4. ComponentRef ；5. ViewContainerRef ；</code></pre><h1 id="二-ElementRef有什么作用"><a href="#二-ElementRef有什么作用" class="headerlink" title="二.ElementRef有什么作用"></a>二.ElementRef有什么作用</h1><p>在应用层直接操作 DOM，就会造成应用层与渲染层之间强耦合，导致我们的应用无法运行在不同环境，如 web worker 中，因为在 web worker 环境中，是不能直接操作 DOM。有兴趣的读者，可以阅读一下 Web Workers 中支持的类和方法这篇文章。通过ElementRef 我们就可以封装不同平台下视图层中的 native 元素 (在浏览器环境中，native 元素通常是指 DOM 元素)，最后借助于 Angular 提供的强大的依赖注入特性，我们就可以轻松地访问到 native 元素。</p><h1 id="三-如何使用ElementRef"><a href="#三-如何使用ElementRef" class="headerlink" title="三.如何使用ElementRef"></a>三.如何使用ElementRef</h1><p>ElementRef 的背后是一个可渲染的具体元素。在浏览器中，它通常是一个 DOM 元素。<br>nativeElement 是背后的原生元素，如果不支持直接访问原生元素，则为 null（比如：在 Web Worker 环境下运行此应用的时候）。<br>比如想要修改给一段富文本添加上颜色，就需要在渲染完成后给指定元素加上样式<br>1、引入相关模块</p><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; Component, ElementRef, OnInit, Renderer2, ViewChild &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core'</span>;</code></pre><p>2、构造函数依赖注入</p><pre><code class="hljs javascript"><span class="hljs-keyword">constructor</span>(    private elementRef: ElementRef,    private renderer: Renderer2) &#123; &#125;</code></pre><p>3、使用属性装饰符@ViewChild</p><pre><code class="hljs javascript">@ViewChild(<span class="hljs-string">'divContent'</span>, &#123;<span class="hljs-attr">static</span>: <span class="hljs-literal">false</span>&#125;) greetDiv: ElementRef;</code></pre><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> [<span class="hljs-attr">innerHTML</span>]=<span class="hljs-string">"hypeLink"</span> #<span class="hljs-attr">divContent</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre><ul><li>Angular8 在使用ViewChild时增加了静态标志static来定义何时需要解析@ViewChild()和@ContentChild();<br>对于静态查询（static：true），查询在视图创建后即可解决，但是在运行变更检测之前。不过，结果永远不会更新以反映视图的更改，例如ngIf和ngFor块的更改。<br>使用动态查询（static：false），分别在ngAfterViewInit()或ngAfterContentInit()之后对@ViewChild()和@ContentChild()进行查询解析。结果将根据视图的更改而更新，例如对ngIf和ngFor块的更改。</li></ul><p>4、通过render2写入样式</p><pre><code class="hljs javascript">ngAfterViewInit() &#123;    <span class="hljs-keyword">this</span>.renderer.setStyle(<span class="hljs-keyword">this</span>.greetDiv.nativeElement, <span class="hljs-string">'color'</span>, <span class="hljs-string">'green'</span>);&#125;</code></pre><h1 id="四-安全风险"><a href="#四-安全风险" class="headerlink" title="四.安全风险"></a>四.安全风险</h1><p>ElementRef 允许直接访问 DOM 会导致应用在 XSS 攻击前面更加脆弱。要仔细评审对 ElementRef 的代码。<br>当需要直接访问 DOM 时，请把本 API 作为最后选择。优先使用 Angular 提供的模板和数据绑定机制。或者你还可以看看 Renderer2，它提供了可安全使用的 API —— 即使环境没有提供直接访问原生元素的功能。</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Angular</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>placeholder兼容性</title>
    <link href="/2020/09/08/placeholder%E5%85%BC%E5%AE%B9%E6%80%A7/"/>
    <url>/2020/09/08/placeholder%E5%85%BC%E5%AE%B9%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<pre><code class="hljs css"><span class="hljs-selector-tag">input</span><span class="hljs-selector-pseudo">::-webkit-input-placeholder</span>, <span class="hljs-selector-tag">textarea</span><span class="hljs-selector-pseudo">::-webkit-input-placeholder</span> &#123;    <span class="hljs-comment">/* WebKit browsers 适配谷歌 */</span>    <span class="hljs-attribute">color</span>: <span class="hljs-number">#666</span>;    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">16px</span>;&#125;<span class="hljs-selector-tag">input</span><span class="hljs-selector-pseudo">:-moz-placeholder</span>, <span class="hljs-selector-tag">textarea</span><span class="hljs-selector-pseudo">:-moz-placeholder</span> &#123;    <span class="hljs-comment">/* Mozilla Firefox 4 to 18 */</span>    <span class="hljs-attribute">color</span>: <span class="hljs-number">#666</span>;    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">16px</span>;&#125;<span class="hljs-selector-tag">input</span><span class="hljs-selector-pseudo">::-moz-placeholder</span>, <span class="hljs-selector-tag">textarea</span><span class="hljs-selector-pseudo">::-moz-placeholder</span> &#123;          <span class="hljs-comment">/* Mozilla Firefox 19+ */</span>    <span class="hljs-attribute">color</span>: <span class="hljs-number">#666</span>;    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">16px</span>;&#125;<span class="hljs-selector-tag">input</span><span class="hljs-selector-pseudo">:-ms-input-placeholder</span>, <span class="hljs-selector-tag">textarea</span><span class="hljs-selector-pseudo">:-ms-input-placeholder</span> &#123;    <span class="hljs-comment">/* Internet Explorer 10-11 */</span>     <span class="hljs-attribute">color</span>: <span class="hljs-number">#666</span>;    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">16px</span>;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS变量设置</title>
    <link href="/2020/07/23/CSS%E5%8F%98%E9%87%8F%E8%AE%BE%E7%BD%AE/"/>
    <url>/2020/07/23/CSS%E5%8F%98%E9%87%8F%E8%AE%BE%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<p>  背景：之前对于大段文案的样式处理，通常采用富文本编辑器里设计颜色、字体等；如果需要根据运营人员配置的颜色来作为一个作用域内的非文本的，比如说分页的数字icon的底色、按钮的颜色、上传组件的颜色时，就需要用到CSS变量来进行样式控制。</p><p>  声明变量的时候，变量名前面要加两根连词线（–）(大小写敏感)</p><pre><code class="hljs css"><span class="hljs-selector-tag">body</span> &#123;    <span class="hljs-attribute">--foo</span>: <span class="hljs-number">#7F583F</span>;    <span class="hljs-attribute">--bar</span>: <span class="hljs-number">#F7EFD2</span>;&#125;</code></pre><p>  使用var()函数读取变量</p><pre><code class="hljs css"><span class="hljs-selector-tag">a</span> &#123;    <span class="hljs-attribute">color</span>: <span class="hljs-built_in">var</span>(--foo);    <span class="hljs-attribute">text-decoration-color</span>: <span class="hljs-built_in">var</span>(--bar);&#125;</code></pre><p>  Js操作CSS变量如下：</p><pre><code class="hljs javascript"><span class="hljs-comment">// 设置变量</span><span class="hljs-built_in">document</span>.body.style.setProperty(<span class="hljs-string">'--primary'</span>, <span class="hljs-string">'#7F583F'</span>);<span class="hljs-comment">// 读取变量</span><span class="hljs-built_in">document</span>.body.style.getPropertyValue(<span class="hljs-string">'--primary'</span>).trim();<span class="hljs-comment">// '#7F583F'</span><span class="hljs-comment">// 删除变量</span><span class="hljs-built_in">document</span>.body.style.removeProperty(<span class="hljs-string">'--primary'</span>);</code></pre><p>  这样就可以做到通过后端返回的数据，来渲染非富文本场景的样式，例如渲染一个按钮的背景色；其中需要注意的是需要等dom节点根据数据渲染完成之后再进行js操作CSS变量的行为；可以采用setTimeout()或者在渲染完成的生命周期钩子里写。</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> mockData = [    &#123;<span class="hljs-attr">text</span>:text1,<span class="hljs-attr">color</span>:red&#125;,    &#123;<span class="hljs-attr">text</span>:text2,<span class="hljs-attr">color</span>:blue&#125;,    &#123;<span class="hljs-attr">text</span>:text3,<span class="hljs-attr">color</span>:green&#125;,    &#123;<span class="hljs-attr">text</span>:text4,<span class="hljs-attr">color</span>:gray&#125;,]mockData.foreach(<span class="hljs-function">(<span class="hljs-params">item,index</span>)=&gt;</span>&#123;    <span class="hljs-built_in">document</span>.getElementById(index+<span class="hljs-string">''</span>).style.setProperty(<span class="hljs-string">'--bg'</span>, item.color);&#125;)</code></pre><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> *<span class="hljs-attr">ngfor</span>=<span class="hljs-string">"let item of mockData,let i =index"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> [<span class="hljs-attr">id</span>]=<span class="hljs-string">"i"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"selectedColor"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>&#123;&#123;item.text&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>different color<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre><pre><code class="hljs css"><span class="hljs-selector-class">.selectedColor</span> <span class="hljs-selector-tag">button</span> &#123;    <span class="hljs-attribute">background-color</span>: <span class="hljs-built_in">var</span>(--bg);&#125;</code></pre><p>  这样CSS变量就提供里js与css通信的一种途径；js可以将任意值存入样式表,不仅是样式元素，事件信息也可以存入样式表中。</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> docStyle = <span class="hljs-built_in">document</span>.documentElement.style;<span class="hljs-built_in">document</span>.addEventListener(<span class="hljs-string">'mousemove'</span>,(e)=&gt;&#123;    docStyle.setProperty(<span class="hljs-string">'--mouse-x'</span>,e.clientX);    docStyle.setProperty(<span class="hljs-string">'--mouse-y'</span>,e.clientY);&#125;)</code></pre>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>伪元素清除浮动</title>
    <link href="/2020/07/07/%E4%BC%AA%E5%85%83%E7%B4%A0%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8/"/>
    <url>/2020/07/07/%E4%BC%AA%E5%85%83%E7%B4%A0%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8/</url>
    
    <content type="html"><![CDATA[<p>  在日常开发工作中，慎用“overflow:hidden;”清除浮动，对于父级元素内的绝对定位或者相对定位可能会起到遮挡作用。</p><p>单伪元素标签法：</p><pre><code class="hljs css"><span class="hljs-selector-class">.clearfix</span><span class="hljs-selector-pseudo">:after</span>&#123;    <span class="hljs-attribute">content</span>:<span class="hljs-string">""</span>;    <span class="hljs-attribute">height</span>:<span class="hljs-number">0</span>;    <span class="hljs-attribute">line-height</span>:<span class="hljs-number">0</span>;    <span class="hljs-attribute">display</span>:block;    <span class="hljs-attribute">visibility</span>:hidden;    <span class="hljs-attribute">clear</span>:both;&#125;<span class="hljs-selector-class">.clearfix</span><span class="hljs-selector-pseudo">:after</span>&#123;    *zoom:1;        /*针对IE6/IE7*/&#125;</code></pre><p>双伪元素标签法：</p><pre><code class="hljs css"><span class="hljs-selector-class">.clearfix</span> <span class="hljs-selector-pseudo">:before</span>,<span class="hljs-selector-class">.clearfix</span><span class="hljs-selector-pseudo">:after</span>&#123;    <span class="hljs-attribute">content</span>: “”;    <span class="hljs-attribute">display</span>: table;&#125;<span class="hljs-selector-class">.clearfix</span><span class="hljs-selector-pseudo">:after</span>&#123;    <span class="hljs-attribute">clear</span>:both;&#125;<span class="hljs-selector-class">.clearfix</span> &#123;    zoom: 1;/兼容IE/ &#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ajax与Fetch的区别</title>
    <link href="/2020/05/23/Ajax%E4%B8%8EFetch%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2020/05/23/Ajax%E4%B8%8EFetch%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<p>fetch是ajax的替代品；基于标准Promise实现支持async/await，可读性更高，避免了ajax回调地狱的痛点。</p><p>Ajax的核心是XMLHttpRequest对象，浏览器正是通过XMLHttpRequest对象进行http通信；</p><pre><code class="hljs javascript"><span class="hljs-comment">//1.创建Ajax对象</span><span class="hljs-keyword">if</span>(<span class="hljs-built_in">window</span>.XMLHttpRequest)&#123;    <span class="hljs-keyword">let</span> oAjax=<span class="hljs-keyword">new</span> XMLHttpRequest();&#125;<span class="hljs-keyword">else</span>&#123;    <span class="hljs-keyword">let</span> oAjax=<span class="hljs-keyword">new</span> ActiveXObject(<span class="hljs-string">"Microsoft.XMLHTTP"</span>); <span class="hljs-comment">//兼容老版本IE</span>&#125;<span class="hljs-comment">//2.连接服务器（打开和服务器的连接）</span>oAjax.open(<span class="hljs-string">'GET'</span>, url, <span class="hljs-literal">true</span>);<span class="hljs-comment">//3.发送</span>oAjax.send();<span class="hljs-comment">//4.接收</span>oAjax.onreadystatechange=<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>)</span>&#123;<span class="hljs-keyword">if</span>(oAjax.readyState==<span class="hljs-number">4</span>)&#123;    <span class="hljs-built_in">console</span>.log(oAjax)    <span class="hljs-keyword">if</span>(oAjax.status==<span class="hljs-number">200</span>)&#123;        <span class="hljs-comment">//alert('成功了：'+oAjax.responseText);</span>        <span class="hljs-built_in">console</span>.log(oAjax)        fnSucc(oAjax.responseText);    &#125;<span class="hljs-keyword">else</span>&#123;        <span class="hljs-comment">//alert('失败了');</span>        <span class="hljs-keyword">if</span>(fnFaild)&#123;            fnFaild();        &#125;    &#125;    &#125;&#125;;</code></pre><p>onreadystatechange 是一个事件句柄。它的值 (state_Change) 是一个函数的名称，当 XMLHttpRequest 对象的状态发生改变时，会触发此函数。状态从 0 (uninitialized) 到 4 (complete) 进行变化。仅在状态为 4 时，我们才执行代码。</p><pre><code class="hljs javascript">fetch(<span class="hljs-string">'http://localhost:3000/api/data'</span>, &#123;    method:<span class="hljs-string">'GET'</span>,    headers: &#123; <span class="hljs-comment">// 请求头（可以是Headers对象，也可是JSON对象）</span>        <span class="hljs-string">'Content-Type'</span>: <span class="hljs-string">'application/json'</span>,        <span class="hljs-string">'Accept'</span>: <span class="hljs-string">'application/json'</span>    &#125;,    mode:<span class="hljs-string">'cors'</span>,<span class="hljs-comment">// 允许发送跨域请求</span>    credentials: <span class="hljs-string">'include'</span>&#125;).then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">response</span>)</span>&#123;    <span class="hljs-comment">//打印返回的json数据</span>    response.json().then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>)</span>&#123;        <span class="hljs-built_in">console</span>.log(data);    &#125;)&#125;).catch(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>)</span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'error: '</span> + e.toString());&#125;)</code></pre><p>1）fetch只对网络请求报错，对400，500都当做成功的请求，需要封装去处理<br>2）fetch默认不会带cookie，需要添加配置项<br>3）fetch不支持abort，不支持超时控制，使用setTimeout及Promise.reject的实现的超时控制并不能阻止请求过程继续在后台运行，造成了流量的浪费<br>4）fetch没有办法原生监测请求的进度，而XHR可以</p><p>ajax和fetch在调用本地文件的时候都存在跨域的问题；ajax可以通过关闭cors限制的chrome实现；fetch却不行，只能用express起本地服务来调用。</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据请求方式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>笔记-1</title>
    <link href="/2020/01/30/%E7%AC%94%E8%AE%B0-1/"/>
    <url>/2020/01/30/%E7%AC%94%E8%AE%B0-1/</url>
    
    <content type="html"><![CDATA[<p>  本着有输入有输出的原则记录一下《大癫狂-群体性狂热与泡沫经济》</p><p>密西西比计划：<br>1、十七世纪约翰劳经法国政府特许，建立可以发行货币的私有银行；以此推行纸币以逐渐取代硬币<br>2、因为劳的特权，其所创立的密西西比公司拥有密西西比河流域独有的贸易特权，由于当时传闻密西西比河遍地所金银；所以公司股票疯涨<br>3、为了解决国债负担的问题，劳利用皇家银行的发行纸币的权利和密西西比公司的股票价值，不断发行股票以偿还国债<br>4、转折点出现，孔蒂亲王因为被劳拒绝了购买密西西比公司的股票，一气之下，要求将自己的纸币兑换成硬币；精明的投机者争相效仿，兑换硬币将硬币运到国外；导致国内流通的硬币极度匮乏，此时市场的纸币流通量是硬币的一倍还多，导致了泡沫经济的崩溃。</p><p>南海泡沫事件：<br>1、十七世纪末至十八世纪初，南海公司认购了1000万英镑的政府债券，为的是帮助英国政府偿还发行的巨额国债；作为条件，政府给予该公司南美洲的贸易垄断权且永久性退税。与密西西比计划类似，当时人们都相信南美的墨西哥秘鲁地下有丰富的金银矿藏。<br>2、1719年，政府允许国债与南海公司股票进行兑换，拉动了股票价格的疯涨。诱发了很多骗子公司上市圈钱<br>3、泡沫的破裂源于西班牙与英国战争爆发，南海贸易被西班牙切断。<br>4、1720年6月，南海公司通过贿赂议会，出台了《泡沫法案》，用于制止各类泡沫公司的膨胀。谁知再许多公司破产之后，公众开始怀疑南海公司的价值，大量抛售股票，股价一落千丈，泡沫破灭。</p><p>荷兰郁金香：<br>炒作郁金香至天价</p><p>以上并称三大经济泡沫事件。</p>]]></content>
    
    
    <categories>
      
      <category>杂文</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Angular构造函数中修饰符的区别</title>
    <link href="/2020/01/09/Angular%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%AD%E4%BF%AE%E9%A5%B0%E7%AC%A6%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2020/01/09/Angular%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%AD%E4%BF%AE%E9%A5%B0%E7%AC%A6%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<p>  众所周知，Angular中引入了大量Java的语法思想，在日常开发中，常常定义变量的时候是不写修饰符的，对修饰符的理解也仅仅停留在Java阶段，如下：</p><pre><code>修饰符       当前类       同包          子类         其他包public       √           √            √             √protected    √           √            √             ×default      √           √            ×             ×private      √           ×            ×             ×</code></pre><p>  在Angular中public、protected、private这几个修饰符也有着类似的意义</p><p>1、public：公有类型（默认），既可以在当前类里使用，也可以在类之外使用</p><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PublicService</span> </span>&#123;    <span class="hljs-keyword">constructor</span>()&#123;&#125;    public country: string = <span class="hljs-string">'China'</span>;&#125;<span class="hljs-comment">//另一个组件component调用时</span><span class="hljs-keyword">constructor</span>(public service: PublicService)&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.service.country) <span class="hljs-comment">//China</span>&#125;</code></pre><p>2、protected： 保护类型，只有在当前类和子类中可以使用</p><p>3、private： 私有类型，只有在当前类中可以使用</p><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ParentViewComponent</span> <span class="hljs-title">implements</span> <span class="hljs-title">OnInit</span> </span>&#123;    <span class="hljs-keyword">constructor</span>()&#123;&#125;    public a:string = <span class="hljs-string">'aaa'</span>;    protected b:string = <span class="hljs-string">'bbb'</span>;    private c:string = <span class="hljs-string">'ccc'</span>;&#125;<span class="hljs-comment">//  这里子类继承父类</span><span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ChildViewComponent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ParentViewComponent</span> <span class="hljs-title">implements</span> <span class="hljs-title">OnInit</span> </span>&#123;    <span class="hljs-keyword">constructor</span>()&#123;        <span class="hljs-keyword">super</span>()<span class="hljs-comment">//执行父类的构造函数；必须至少执行一次，用来创建父类的this</span>    &#125;    ngOnInit()&#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.a);<span class="hljs-comment">//能访问</span>        <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.b);<span class="hljs-comment">//能访问</span>        <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.c);<span class="hljs-comment">//报错</span>    &#125;&#125;</code></pre><p>4、既然详细了解了修饰符，typescript的关键字super()也是类似于java里super的思想</p><pre><code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Parent</span> </span>&#123;    <span class="hljs-keyword">constructor</span>() &#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'parent'</span>)    &#125;    <span class="hljs-keyword">get</span>() &#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"吃饭"</span>)    &#125;     &#125;  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Child</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Parent</span> </span>&#123;    <span class="hljs-keyword">constructor</span>() &#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"child"</span>)        <span class="hljs-keyword">super</span>()    &#125;    <span class="hljs-keyword">get</span>() &#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"不吃饭"</span>)    &#125;    init() &#123;        <span class="hljs-keyword">super</span>.get()    &#125;&#125;  <span class="hljs-keyword">var</span> children = <span class="hljs-keyword">new</span> Child();children.init();<span class="hljs-comment">//child</span><span class="hljs-comment">//parent</span><span class="hljs-comment">//吃饭</span></code></pre><p>这个例子说明typescript的super.method()可以调用父类同名的方法；<br>实际上就是js中的Parent.prototype.method.call(this)</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Angular</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ios微信浏览器输入框失去焦点后页面无响应问题</title>
    <link href="/2019/12/05/ios%E5%BE%AE%E4%BF%A1%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5%E6%A1%86%E5%A4%B1%E5%8E%BB%E7%84%A6%E7%82%B9%E5%90%8E%E9%A1%B5%E9%9D%A2%E6%97%A0%E5%93%8D%E5%BA%94%E9%97%AE%E9%A2%98/"/>
    <url>/2019/12/05/ios%E5%BE%AE%E4%BF%A1%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5%E6%A1%86%E5%A4%B1%E5%8E%BB%E7%84%A6%E7%82%B9%E5%90%8E%E9%A1%B5%E9%9D%A2%E6%97%A0%E5%93%8D%E5%BA%94%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>  问题描述：在ios微信浏览器上访问表单注册页面，当输入框输入文字完毕，微信键盘收回之后，页面出现失去焦点现象，点击仍和按钮或者输入框都没反应</p><p>  原因：微信键盘弹起后，若愿输入框被遮挡，页面整体会向上移动，当键盘收起时页面却未恢复，导致页面点击没反应</p><p>  解决方法：当输入框失去焦点时调用一下方法能完美解决问题</p><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">kickBack</span>(<span class="hljs-params"></span>) </span>&#123;    setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;        <span class="hljs-built_in">window</span>.scrollTo(<span class="hljs-number">0</span>, <span class="hljs-built_in">document</span>.body.scrollTop + <span class="hljs-number">1</span>);        <span class="hljs-built_in">document</span>.body.scrollTop &gt;= <span class="hljs-number">1</span> &amp;&amp; <span class="hljs-built_in">window</span>.scrollTo(<span class="hljs-number">0</span>, <span class="hljs-built_in">document</span>.body.scrollTop - <span class="hljs-number">1</span>);      &#125;, <span class="hljs-number">10</span>)&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>兼容性</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>EXIF处理照片信息</title>
    <link href="/2019/10/14/EXIF%E5%A4%84%E7%90%86%E7%85%A7%E7%89%87%E4%BF%A1%E6%81%AF/"/>
    <url>/2019/10/14/EXIF%E5%A4%84%E7%90%86%E7%85%A7%E7%89%87%E4%BF%A1%E6%81%AF/</url>
    
    <content type="html"><![CDATA[<p>  最近在处理人脸照片时遇到一个奇怪现象，iphone 自拍照片总是显示未识别到人脸，Android 机则未出现任何问题。经过一番排查测试发现，iphone 手机在自拍时生成的人脸照片尽管显示是正常的，但是当转成 base64 格式之后恢复，自动逆时针旋转 45 度。导致人脸识别时，旋转之后的照片是无法检测出人脸的，带来极为糟糕的使用体验；所以需要在图片传给后端之前做一次复位操作。</p><p>  解决方案就是读取照片中的方向信息，将旋转的照片进行复位；这里的读取信息使用开源的 exif-js，复位操作由于图片转 base64 格式一般使用 canvas 画布显示，所以旋转操作用 canvas 上下文的 rotate()或者 transform()皆可。</p><p>  下图展示了照片 exif 方向参数的八种位置:</p><p><img src="/image/exif/orient_flag.gif" srcset="/img/loading.gif" alt=""></p><p>  经过测试，苹果手机前置摄像头直立拍照对应 6 号位，摄像头在右横向拍照对应 1 号位(常规位置)，摄像头在左横向拍照对应 8 号位(需要转 180 度)<br>  示例代码如下：</p><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> imgObj = <span class="hljs-keyword">new</span> Image();imgObj.src = imagesrc;setTimeout()&#123;()=&gt;&#123;    <span class="hljs-keyword">let</span> orientation;                            <span class="hljs-comment">//方向参数</span>    EXIF.getData(imgObj, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;        orientation = EXIF.getTag(<span class="hljs-keyword">this</span>, <span class="hljs-string">'Orientation'</span>);    &#125;    <span class="hljs-keyword">let</span> imgWidth = imgObj.width;                   <span class="hljs-comment">//图片宽度</span>    <span class="hljs-keyword">let</span> imgHeight = imgObj.height;                 <span class="hljs-comment">//图片高度</span>    <span class="hljs-keyword">let</span> canvas = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">'canvas'</span>);    <span class="hljs-keyword">let</span> ctx = canvas.getContext(<span class="hljs-string">'2d'</span>);    <span class="hljs-keyword">let</span> ratio = imgWidth/imgHeight;    <span class="hljs-keyword">if</span>(imgWidth&gt;imgHeight &amp;&amp; imgWidth&gt;<span class="hljs-number">750</span>)&#123;        imgWidth = <span class="hljs-number">750</span>;        imgHeight = <span class="hljs-built_in">Math</span>.ceil(<span class="hljs-number">750</span>/ratio);    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(imgWidth&lt;imgHeight &amp;&amp; imgHeight&gt;<span class="hljs-number">1350</span>)&#123;        imgWidth = <span class="hljs-built_in">Math</span>.ceil(<span class="hljs-number">1350</span>/ratio);        imgHeight = <span class="hljs-number">1350</span>;    &#125;    <span class="hljs-keyword">if</span>(orientation == <span class="hljs-number">6</span>)&#123;        canvas.width = imgHeight;        canvas.height = imgWidth;        ctx.rotate(<span class="hljs-number">90</span> * <span class="hljs-built_in">Math</span>.PI / <span class="hljs-number">180</span>);        ctx.drawImage(imgObj, <span class="hljs-number">0</span>, -imgHeight, imgWidth, imgHeight);        <span class="hljs-comment">//画布以(0,-imgHeight)为焦点顺时针旋转90度，此时宽为图片高，高为图片宽</span>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(orientation == <span class="hljs-number">3</span>) &#123;        canvas.width = imgWidth;        canvas.height = imgHeight;        ctx.rotate(<span class="hljs-number">180</span> * <span class="hljs-built_in">Math</span>.PI / <span class="hljs-number">180</span>);        ctx.drawImage(imgObj, -imgWidth, -imgHeight, imgWidth, imgHeight);    &#125;<span class="hljs-keyword">else</span> &#123;        canvas.width = imgWidth;        canvas.height = imgHeight;        ctx.drawImage(imgObj, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, imgWidth, imgHeight);    &#125;    <span class="hljs-keyword">let</span> database64 = canvas.toDataURL(<span class="hljs-string">"image/jpeg"</span>,<span class="hljs-number">0.6</span>)&#125;,<span class="hljs-number">500</span>&#125;</code></pre><p>  p.s. exif-js 代码库存在一个类型校验缺陷，使用时需要修正一下，如下所示</p><p><img src="/image/exif/github.png" srcset="/img/loading.gif" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Exif</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>模拟eventloop demo</title>
    <link href="/2019/10/03/%E6%A8%A1%E6%8B%9Feventloop-demo/"/>
    <url>/2019/10/03/%E6%A8%A1%E6%8B%9Feventloop-demo/</url>
    
    <content type="html"><![CDATA[<p>  Node的异步非阻塞I/O特性依赖于其内部的事件循环机制；<br>  下面简单模拟一下事件循环的实现：</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> eventloop = &#123;    queue : [],    loop()&#123;        <span class="hljs-keyword">while</span>(<span class="hljs-keyword">this</span>.queue.length &gt; <span class="hljs-number">0</span>)&#123;            <span class="hljs-keyword">var</span> callback = <span class="hljs-keyword">this</span>.queue.shift();            callback();        &#125;        setTimeout(<span class="hljs-keyword">this</span>.loop.bind(<span class="hljs-keyword">this</span>),<span class="hljs-number">50</span>);   <span class="hljs-comment">//这里this指的是eventloop对象</span>    &#125;,    add(callback)&#123;        <span class="hljs-keyword">this</span>.queue.push(callback);    &#125;&#125;eventloop.loop();setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;    eventloop.add(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>)    &#125;)&#125;,<span class="hljs-number">500</span>)setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;    eventloop.add(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-number">2</span>)    &#125;)&#125;,<span class="hljs-number">800</span>)</code></pre><p>  这里间隔500毫秒和800毫秒向循环里添加了两个事件，eventloop会不间断得去监听是否有新事件进入执行栈。</p><div class="note note-success">            <p>事件循环：<br>每次循环过程称为Tick（即查看是否有但出来事件，将待处理事件存储在任务队列中），若有，则取出事件及回调函数放入stack由主线程执行。</p>          </div><div class="note note-success">            <p>任务队列：<br>异步操作将相关回调添加到Task Queue中，异步操作由浏览器内核webcore执行。</p>          </div>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Node</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>super关键字</title>
    <link href="/2019/10/03/super%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <url>/2019/10/03/super%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    
    <content type="html"><![CDATA[<p>  this和super的区别：<br>  this关键词指向函数所在的当前对象<br>  super指向的是当前对象的原型对象</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> EventEmitter  = <span class="hljs-built_in">require</span>(<span class="hljs-string">'events'</span>).EventEmitter;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Publishorder</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">EventEmitter</span> </span>&#123;    <span class="hljs-keyword">constructor</span>()&#123;        <span class="hljs-keyword">super</span>();        setInterval(<span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span>&#123;            <span class="hljs-keyword">this</span>.emit(<span class="hljs-string">'neworder'</span>, &#123; <span class="hljs-attr">price</span>: <span class="hljs-built_in">Math</span>.random() * <span class="hljs-number">100</span> &#125;);        &#125;,<span class="hljs-number">3000</span>)    &#125;&#125;</code></pre><p>  上面写了一个每隔3秒发布一个随机价格订单的事件发射器的类Publishorder，其中super()指的是父类的构造函数，即Nodejs中的events.EventEmitter；如果不去调用父类构造函数，将无法在构造函数中使用this。即抛出这样一个错误：</p><pre><code>/Users/xuan/Desktop/Daily Demo/Daily-Demo/Node/eventemitter.js:6    setInterval(()=&gt;{    ^ReferenceError: Must call super constructor in derived class before accessing &apos;this&apos; or returning from derived constructor    at new Publishorder (/Users/xuan/Desktop/Daily Demo/Daily-Demo/Node/eventemitter.js:6:9)    at Object.&lt;anonymous&gt; (/Users/xuan/Desktop/Daily Demo/Daily-Demo/Node/eventemitter.js:12:22)    at Module._compile (internal/modules/cjs/loader.js:778:30)    at Object.Module._extensions..js (internal/modules/cjs/loader.js:789:10)    at Module.load (internal/modules/cjs/loader.js:653:32)    at tryModuleLoad (internal/modules/cjs/loader.js:593:12)    at Function.Module._load (internal/modules/cjs/loader.js:585:3)    at Function.Module.runMain (internal/modules/cjs/loader.js:831:12)    at startup (internal/bootstrap/node.js:283:19)    at bootstrapNodeJSCore (internal/bootstrap/node.js:622:3)</code></pre><p>  那么为什么javascript要有这样一个限制？因为有继承关系，子类创建了对象会用到父类的属性方法，所以父类也要初始化，不然继承父类而不用父类的属性和方法，那继承还有什么意义。<br>  所以，Class中的 super()，它在这里表示父类的构造函数，用来新建父类的 this 对象。<br>这里的super()相当于Parent.prototype.constructor.call(this)</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ngFor-trackBy</title>
    <link href="/2019/09/07/ngFor-trackBy/"/>
    <url>/2019/09/07/ngFor-trackBy/</url>
    
    <content type="html"><![CDATA[<p>  今天在开发自定义表单功能时遇到这么一个问题，场景大致是通过循环生成所需的n个输入框，彼此之间保持独立。</p><p>先看这段代码存在到问题：</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> *<span class="hljs-attr">ngFor</span>=<span class="hljs-string">"let child of item.option; let k = index"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">nz-input</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"option_input"</span> [(<span class="hljs-attr">ngModel</span>)]=<span class="hljs-string">"child"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">i</span> <span class="hljs-attr">nz-icon</span> [<span class="hljs-attr">nzType</span>]=<span class="hljs-string">"'close'"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"btnIcon closeBtn"</span> (<span class="hljs-attr">click</span>)=<span class="hljs-string">"delItem(i,k)"</span> *<span class="hljs-attr">ngIf</span>=<span class="hljs-string">'item.option.length&gt;1'</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">i</span> <span class="hljs-attr">nz-icon</span> [<span class="hljs-attr">nzType</span>]=<span class="hljs-string">"'plus'"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"btnIcon plusBtn"</span> (<span class="hljs-attr">click</span>)=<span class="hljs-string">"addItem(i,k)"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre><p>  现象是新增输入框时正常工作，但在删除时，尽管ts代码获取到了所需要删除的index并在数据层更新了列表数组，但在页面渲染时删除的却是数组的最后一项。这时猜测视图上输入框双向绑定的属性与数组里到元素并没有一一对应上，才导致渲染的错误；于是修改为以下代码：</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> *<span class="hljs-attr">ngFor</span>=<span class="hljs-string">"let child of item.option; let k = index"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">nz-input</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"option_input"</span> [(<span class="hljs-attr">ngModel</span>)]=<span class="hljs-string">"item.option[k]"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">i</span> <span class="hljs-attr">nz-icon</span> [<span class="hljs-attr">nzType</span>]=<span class="hljs-string">"'close'"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"btnIcon closeBtn"</span> (<span class="hljs-attr">click</span>)=<span class="hljs-string">"delItem(i,k)"</span> *<span class="hljs-attr">ngIf</span>=<span class="hljs-string">'item.option.length&gt;1'</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">i</span> <span class="hljs-attr">nz-icon</span> [<span class="hljs-attr">nzType</span>]=<span class="hljs-string">"'plus'"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"btnIcon plusBtn"</span> (<span class="hljs-attr">click</span>)=<span class="hljs-string">"addItem(i,k)"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre><p>  但问题并没有解决，删除索引错乱的问题解决了，但对于每个input框都存在按键之后立即失去焦点的问题，想了一下还是视图与模型并没有对应的问题，于是翻文档找到了如下解决方案：</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> *<span class="hljs-attr">ngFor</span>=<span class="hljs-string">"let child of item.option; trackBy: trackByIndex; let k = index"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">nz-input</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"option_input"</span> [(<span class="hljs-attr">ngModel</span>)]=<span class="hljs-string">"item.option[k]"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">i</span> <span class="hljs-attr">nz-icon</span> [<span class="hljs-attr">nzType</span>]=<span class="hljs-string">"'close'"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"btnIcon closeBtn"</span> (<span class="hljs-attr">click</span>)=<span class="hljs-string">"delItem(i,k)"</span> *<span class="hljs-attr">ngIf</span>=<span class="hljs-string">'item.option.length&gt;1'</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">i</span> <span class="hljs-attr">nz-icon</span> [<span class="hljs-attr">nzType</span>]=<span class="hljs-string">"'plus'"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"btnIcon plusBtn"</span> (<span class="hljs-attr">click</span>)=<span class="hljs-string">"addItem(i,k)"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre><p>  以上问题全部解决，先解释一下一开始两种情况出现的原因。只删除最后一项的场景，通过打印集合数据可以知道页面输入值根据[(ngModel)]=”child”并未同步给数组，数组中仍然是初始化的空字符串，所以当删除一项时，视图只知道循环减一并不知道删除哪项。而对于[(ngModel)]=”item.option[k]”，视图与集合同步，只删除最后一项的问题解决，但存在另一个问题。</p><p>  我们知道对于双向绑定的属性可以做到同步更新视图，但是对于一个集合（这里是一个数组），视图无法去跟踪集合里每一个项，也就是当集合数据发生改变时，视图并不知道哪一项多了或哪一项少了，Angular所做的只能是将集合里的项全部移除再重新添加，涉及到的页面重新渲染，造成大量不必要到DOM操作，引入trackBy的目的是优化渲染性能，视图根据trackBy返回的唯一标示去重新绘制仅发生改变的项。</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> trackByIdentity = <span class="hljs-function">(<span class="hljs-params">index: number, item: any</span>) =&gt;</span> item;</code></pre><p>  trackBy函数需要两个参数，第一个是当前项的index，第二个是当前项，并返回一个唯一的标识,相当于同步返回集合内发生了什么变化给视图用于重新绘制页面。</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Angular</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>xjb写</title>
    <link href="/2019/09/03/xjb%E5%86%99/"/>
    <url>/2019/09/03/xjb%E5%86%99/</url>
    
    <content type="html"><![CDATA[<p>  今年南京的九月份是真tmd冷啊！</p><p>  数了数，肖申克的救赎电影看了两遍了，这两天随手翻了翻把斯蒂芬金的原著也看了一遍，没想到原著比想象中的简短了许多，也和电影的剧情稍有不同。</p><p>  第一遍看的时候大约是大三大四的时候，已经记不清什么了，只觉得安迪nb，真能忍，真有耐心，真不像个人。。。</p><p>  第二遍是去年看的，逐渐能够感受到安迪也有脆弱想放弃的时候，但想不通他为什么早已挖好隧道却不立刻逃走，这段在原著里有解释，感觉原著的人物更加立体真实了。记得啥子还？记得“希望是个好东西，也许是世界上最好的东西，好东西永远不会消逝的”，虽然比起主角光环要真实了很多，但是还是感觉有点神话色彩，离现实生活好远，可能也是没遭过牢狱之灾。。。</p><p>  今天看完原著，一个新的视角觉得很有意思，就是安迪也不能说天天挖洞吧，至少这二十七年随便哪次突击检查都有可能发现他的秘密，为什么狱警没发现，抛开运气与文学色彩来看；有时候，看似司空见惯习以为常的东西，其实在不知不觉中发生改变，以为它一成不变是因为看待它的人，用的是一成不变的眼光和心态。对于狱警来说，安迪是模范犯人，是大家的金融工具，将肖申克图书馆当作生命的全部；对这样一个人产生怀疑真的太难了。</p><p>  电影里安迪永远一副闲庭信步，处之泰然的样子，可是他压得赌注之大难以想象；就像瑞德所说，在封闭的监狱里，不可能做到万全的准备，如果污水管出口被铁网焊死了呢？如果安迪在出逃前被提前保释，清扫房间了呢？不可预料的意外太多了，想的越多越迈不出那第一步。</p>]]></content>
    
    
    <categories>
      
      <category>杂文</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>跳出forEach循环</title>
    <link href="/2019/09/02/%E8%B7%B3%E5%87%BAforEach%E5%BE%AA%E7%8E%AF/"/>
    <url>/2019/09/02/%E8%B7%B3%E5%87%BAforEach%E5%BE%AA%E7%8E%AF/</url>
    
    <content type="html"><![CDATA[<p>  在循环遍历数组时，for循环可以通过break或者continue进行终止跳出操作；但是箭头函数的普及更多得使用forEach去做循环遍历，这时候想要中途跳出该怎么办呢？</p><p>构造场景,将数组中第一个值为5的元素改为10:</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>];<span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>;i&lt;arr.length;i++)&#123;    <span class="hljs-keyword">if</span>(arr[i] == <span class="hljs-number">5</span>)&#123;        arr[i] = <span class="hljs-number">10</span>;        <span class="hljs-keyword">break</span>;    &#125;    <span class="hljs-built_in">console</span>.log(arr[i]);&#125;<span class="hljs-comment">//0,1,2,3,4,10</span></code></pre><p>用forEach改写<br>方案一：</p><pre><code class="hljs javascript">arr.forEach(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> &#123;    <span class="hljs-keyword">if</span>(item == <span class="hljs-number">5</span>)&#123;        item = <span class="hljs-number">10</span>;        <span class="hljs-keyword">break</span>;    &#125;    <span class="hljs-built_in">console</span>.log(item);&#125;)<span class="hljs-comment">//Uncaught SyntaxError: Illegal break statement</span></code></pre><p>所以原生forEach()不支持break操作；</p><p>方案二：</p><pre><code class="hljs javascript">arr.forEach(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> &#123;    <span class="hljs-keyword">if</span>(item == <span class="hljs-number">5</span>)&#123;        item = <span class="hljs-number">10</span>;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125;    <span class="hljs-built_in">console</span>.log(item);&#125;)<span class="hljs-comment">//0,1,2,3,4,6,7,8,9</span></code></pre><p>return false起作用了，但仅仅是终止本次继续执行，后续的循环继续执行；</p><p>方案三：</p><pre><code class="hljs javascript"><span class="hljs-keyword">try</span> &#123;    <span class="hljs-keyword">const</span> arr = [<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>];    arr.forEach(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> &#123;        <span class="hljs-keyword">if</span>(item == <span class="hljs-number">5</span>)&#123;            item = <span class="hljs-number">10</span>;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"EndIterative"</span>);        &#125;        <span class="hljs-built_in">console</span>.log(item);    &#125;)&#125;<span class="hljs-keyword">catch</span>(e)&#123;    <span class="hljs-keyword">if</span>(e.message!=<span class="hljs-string">"EndIterative"</span>) <span class="hljs-keyword">throw</span> e;&#125;<span class="hljs-comment">//0,1,2,3,4</span></code></pre><p>forEach()无法通过正常流程终止，所以可以通过抛出异常的方式实现终止循环的目的；</p><p>方案四：</p><pre><code class="javascript">arr.every(<span class="function"><span class="params">item</span> =&gt;</span> {    <span class="keyword">if</span>(item == <span class="number">5</span>){        item = <span class="number">10</span>;        <span class="keyword">return</span> <span class="literal">false</span>;    }    <span class="built_in">console</span>.log(item);    <span class="keyword">return</span> <span class="literal">true</span>;})<span class="comment">//0,1,2,3,4,false</span>arr.some(<span class="function"><span class="params">item</span> =&gt;</span> {    <span class="keyword">if</span>(item == <span class="number">5</span>){        item = <span class="number">10</span>;        <span class="keyword">return</span> <span class="literal">true</span>;    }    <span class="built_in">console</span>.log(item);    <span class="keyword">return</span> <span class="literal">false</span>;})<span class="comment">//0,1,2,3,4,true</span></code></pre><p>可以对于some(),return true时会终止循环，对于every()，return false时会种植循环。</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>动态加载文件</title>
    <link href="/2019/08/20/%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E6%96%87%E4%BB%B6/"/>
    <url>/2019/08/20/%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E6%96%87%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<p>  业务背景：在加载js或css文件时通常在页头使用head标签加载，然而有的情况需要动态加载文件，例如监听某个事件，当触发时执行加载代码，可以使用如下的方法。</p><pre><code class="hljs javascript">loadedScripts: string[] = [];<span class="hljs-comment">//已经加载过的资源文件</span><span class="hljs-comment">/**</span><span class="hljs-comment">* <span class="hljs-doctag">@param <span class="hljs-variable">sctipts</span></span></span><span class="hljs-comment">* 某一组件中需要同步加载的js数组 如['a.js',['b.js,c.js'].'d.js']表示a加载完成后，加载b和c，最后加载d</span><span class="hljs-comment">* <span class="hljs-doctag">@param </span>callback </span><span class="hljs-comment">* 全部加载完成后的回调函数</span><span class="hljs-comment">*/</span>loadScript(path,scripts,callback)&#123;<span class="hljs-keyword">let</span> _t = <span class="hljs-keyword">this</span>;<span class="hljs-keyword">if</span>(scripts.length)&#123;    <span class="hljs-keyword">let</span> item = scripts.shift();    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> item === <span class="hljs-string">'string'</span>) &#123;        <span class="hljs-keyword">if</span> (_t.loadedScripts.indexOf(item)&gt;=<span class="hljs-number">0</span>) &#123;            _t.loadScript(path,scripts,callback);        &#125;<span class="hljs-keyword">else</span>&#123;            <span class="hljs-keyword">let</span> onload = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;                _t.loadedScripts.push(item);                _t.loadScript(path,scripts,callback);            &#125;            <span class="hljs-keyword">let</span> name = item.split(<span class="hljs-string">'.css'</span>);            <span class="hljs-keyword">let</span> isCss = name.length===<span class="hljs-number">2</span> &amp;&amp; !name[<span class="hljs-number">1</span>];            <span class="hljs-keyword">if</span> (isCss) &#123;                <span class="hljs-keyword">let</span> link = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">'link'</span>);                <span class="hljs-built_in">document</span>.head.appendChild(link);                link.rel = <span class="hljs-string">'stylesheet'</span>;                link.onload = onload;                link.type = <span class="hljs-string">'text/css'</span>;                link.href = <span class="hljs-string">'./assets/lib'</span> + path + <span class="hljs-string">'/'</span> + item;            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-keyword">let</span> script = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">'script'</span>);                <span class="hljs-built_in">document</span>.head.appendChild(script);                script.onload = onload;                script.src = <span class="hljs-string">'./assets/lib'</span> + path + <span class="hljs-string">'/'</span> + item + <span class="hljs-string">'.js'</span>;            &#125;        &#125;    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Object</span>.prototype.toString.call(item)===<span class="hljs-string">"[object Array]"</span>) &#123;        <span class="hljs-keyword">if</span> (item.length) &#123;            <span class="hljs-keyword">let</span> loadCount = <span class="hljs-number">0</span>;            item.forEach(<span class="hljs-function"><span class="hljs-params">s</span>=&gt;</span>&#123;                <span class="hljs-keyword">if</span> (_t.loadedScripts.indexOf(s)&gt;=<span class="hljs-number">0</span>) &#123;                    loadCount++;                    _t.loadedScripts.push(s);                    <span class="hljs-keyword">if</span> (loadCount===item.length) &#123;                        _t.loadScript(path,scripts,callback);                    &#125;                &#125; <span class="hljs-keyword">else</span> &#123;                    <span class="hljs-keyword">let</span> onload = <span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span>&#123;                        loadCount++;                        _t.loadedScripts.push(s);                        <span class="hljs-keyword">if</span> (loadCount===item.length) &#123;                            _t.loadScript(path,scripts,callback);                        &#125;                    &#125;                    <span class="hljs-keyword">let</span> name = item.split(<span class="hljs-string">'.css'</span>);                    <span class="hljs-keyword">let</span> isCss = name.length===<span class="hljs-number">2</span> &amp;&amp; !name[<span class="hljs-number">1</span>];                    <span class="hljs-keyword">if</span> (isCss) &#123;                        <span class="hljs-keyword">let</span> link = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">'link'</span>);                        <span class="hljs-built_in">document</span>.head.appendChild(link);                        link.rel = <span class="hljs-string">'stylesheet'</span>;                        link.onload = onload;                        link.type = <span class="hljs-string">'text/css'</span>;                        link.href = <span class="hljs-string">'./assets/lib'</span> + path + <span class="hljs-string">'/'</span> + item;                    &#125; <span class="hljs-keyword">else</span> &#123;                        <span class="hljs-keyword">let</span> script = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">'script'</span>);                        <span class="hljs-built_in">document</span>.head.appendChild(script);                        script.onload = onload;                        script.src = <span class="hljs-string">'./assets/lib'</span> + path + <span class="hljs-string">'/'</span> + item + <span class="hljs-string">'.js'</span>;                    &#125;                &#125;            &#125;)        &#125; <span class="hljs-keyword">else</span> &#123;            _t.loadScript(path,[],callback);        &#125;    &#125;&#125;<span class="hljs-keyword">else</span>&#123;    callback &amp;&amp; callback(<span class="hljs-built_in">window</span>);&#125;</code></pre><p>P.S. 为什么要用Object.prototype.toString.call(obj)检测对象类型？</p><p>  首先想到的是typeof，但是它只能检测六种基本数据类型，当需要区分同为Object的各种引用类型时不适用。<br>其次想到的是instanceof，它是用来用来测试一个对象在其原型链中是否存在一个构造函数的 prototype 属性；</p><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [];<span class="hljs-keyword">let</span> str = <span class="hljs-string">""</span>;arr <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Array</span>; <span class="hljs-comment">//true</span>str <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Array</span>; <span class="hljs-comment">//false</span></code></pre><p>这样可以达到检测引用类型值的目的，但是不能直接返回值的类型。</p><p>  所以使用Object.prototype.toString.call(obj)<br>  这里引入另一个问题，同样是将对象转换为字符串，为什么不能使用obj.toString()呢？<br>因为toString为Object的原型方法，而Array 、Function等类型作为Object的实例，都重写了toString方法。不同的对象类型调用toString方法时，根据原型链的知识，调用的是对应的重写之后的toString方法（Function类型返回内容为函数体的字符串，Array类型返回元素组成的字符串等等），而不会去调用Object上原型toString方法（返回对象的具体类型），所以采用obj.toString()不能得到其对象类型，只能将obj转换为字符串类型；因此，在想要得到对象的具体类型时，应该调用Object上原型toString方法。</p><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>];<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Array</span>.prototype.hasOwnProperty(<span class="hljs-string">"toString"</span>));<span class="hljs-comment">//true</span><span class="hljs-built_in">console</span>.log(arr.toString());<span class="hljs-comment">//1,2,3</span><span class="hljs-keyword">delete</span> <span class="hljs-built_in">Array</span>.prototype.toString;<span class="hljs-comment">//delete操作符可以删除实例属性</span><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Array</span>.prototype.hasOwnProperty(<span class="hljs-string">"toString"</span>));<span class="hljs-comment">//false</span><span class="hljs-built_in">console</span>.log(arr.toString());<span class="hljs-comment">//"[object Array]"</span></code></pre><p>  当删除Array重写的toString()后，arr.toString()将不再屏蔽Object原型方法的实例方法，而是沿着原型链去调用Object的toString方法，返回结果与Object.prototype.toString.call(arr)相同。</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>寄生虫</title>
    <link href="/2019/08/13/%E5%AF%84%E7%94%9F%E8%99%AB/"/>
    <url>/2019/08/13/%E5%AF%84%E7%94%9F%E8%99%AB/</url>
    
    <content type="html"><![CDATA[<p>  听取男神的安利，看完了韩国电影寄生虫立刻写一篇影评。此外特地鸣谢钟博士提供的枪版链接，让我没了推辞到周末看的借口，FSNB（破音）！</p><p>  影片刚开始对长子基宇家庭环境对描写让我一度以为是上个世纪拍的影片。一家四口生活在半地下室对简陋且拥挤对房屋里，游手好闲得浑浑噩噩得生活着。</p><p>  故事的起因大致就是基宇借同学引荐机会进入富豪社长家当家教，一步步将一家四口都引荐到富豪家获得工作。一开始我也对剧情产生怀疑，社长有钱有权力完全可以调查这一家人的背景；但是后来想想，对于家政及家教这种事由信任的人一步步引荐的选择，他似乎没理由怀疑；而且他们一家在各自本职工作上都满足了社长家各位的需求。男神说这是反映韩国阶级差距的电影，阶级差距这种东西有时候显得很远有时候显得很近；电影一开始，基宇一家本完全没有机会接触到社长这样的人物，这时候看他们离的好远；但是他们真正去到社长家工作时又完全满足了社长的要求；给他们以自己能过上上流社会生活的错觉。</p><p>  记录几个印象深刻的片段：<br>1、一家人在雨天仓皇逃回自己地下室一般的房子时的描述。男神说这是一路向下，色调渐暗的隐喻手法。太专业了，自己看的时候完全没理解到位，NSNB！给为印象深刻的是，这只是一段遭遇雨天污水溢出的天灾，基宇父亲却将自己一家人比做四散逃窜的蟑螂。比起住所的差别，更大的是心理落差，毕竟几小时前他们还以为自己可以永远住在豪宅里。突然想到之前一位同事说的话，很受用“秘密太多的人会活得很累”；也是一家人从一开始对欺骗始终压抑着他们对内心。</p><p>2、基宇穿着赈灾的衣服问小姑娘自己是否配得上他们家的聚会，小姑娘很诚恳的说很合适。这里也许有出于她的爱慕之情，不过在她看来基宇和其他亲朋好友并无区别。但是基宇却觉得自己很不搭这样的场合，也许导演是想表述阶级上如天堑般的差异，更多的是来自贫穷带来的不自信而并非穿着打扮这样对物质条件。基宇也是无法忍受这样的落差才会去地下室想杀了那对同是寄生虫的夫妇造成所有人命运的转折。</p><p>3、基宇父亲基泽最后捅向社长胸口的一刀，一方面来自他积怨已久的仇富心理，社长对地下室气味的敏感让他感觉到了侮辱。这里确实感觉父亲完全内心已经扭曲，整体而言社长一家的态度还是得体尊敬的，然而就是一些对气味不适应的小细节上，不断刺激着父亲的内心。另一方面是社长完全无视自己已被捅伤的女儿，只想着带自己儿子去医院；似乎看到女儿医治无望的父亲将全部仇恨都指向给他内心带来各种不公平的社长。</p><p>  影片最后的结局也很有意思，基泽一直藏身于地下室过着担惊受怕的生活，基宇也梦想自己能发家致富买下宅子让父亲体面得从地下室走出来。但是一切都是梦，现实的差距只能让他们维持现状忍受着难以相见的痛苦。此时最近常听的一段歌词私以为很应景“明明我已昼夜无间踏尽面前路；梦想中的彼岸为何还未到；明明我已奋力无间天天上路；我不死也为活得好；有没有终点谁能知道；在这尘世的无间道”。佛曰:「受身无间者永远不死，去寿长乃无间地狱中之大劫。」犯下的罪终究逃不过命运，基宇一家最后虽免于牢狱之灾，也是尽受终极无间之苦。</p>]]></content>
    
    
    <categories>
      
      <category>杂文</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>响应码报错的优化写法</title>
    <link href="/2019/08/03/%E5%93%8D%E5%BA%94%E7%A0%81%E6%8A%A5%E9%94%99%E7%9A%84%E4%BC%98%E5%8C%96%E5%86%99%E6%B3%95/"/>
    <url>/2019/08/03/%E5%93%8D%E5%BA%94%E7%A0%81%E6%8A%A5%E9%94%99%E7%9A%84%E4%BC%98%E5%8C%96%E5%86%99%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>在接口调用时，根据不同的响应码返回给用户相应的提示；通常用简单的if else 就能实现；<br>如下：</p><pre><code class="hljs javascript"><span class="hljs-keyword">this</span>.orderService.getOrder(id)  .subscribe(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;    <span class="hljs-keyword">if</span> (res.code == <span class="hljs-string">'00000'</span>) &#123;      &lt;!-- 响应正确的业务代码 --&gt;    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (res.code == <span class="hljs-string">'00001'</span>) &#123;        alert(<span class="hljs-string">"报错原因A"</span>)    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (res.code == <span class="hljs-string">'00002'</span>) &#123;        alert(<span class="hljs-string">"报错原因B"</span>)    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (res.code == <span class="hljs-string">'00003'</span>) &#123;        alert(<span class="hljs-string">"报错原因C"</span>)    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (res.code == <span class="hljs-string">'00004'</span>) &#123;        alert(<span class="hljs-string">"报错原因D"</span>)    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (res.code == <span class="hljs-string">'00005'</span>) &#123;        alert(<span class="hljs-string">"报错原因E"</span>)    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (res.code == <span class="hljs-string">'00006'</span>) &#123;        alert(<span class="hljs-string">"报错原因F"</span>)    &#125;<span class="hljs-keyword">else</span> &#123;        alert(<span class="hljs-string">"统一通用报错"</span>)    &#125;  &#125;, (error) =&gt; &#123;    <span class="hljs-built_in">console</span>.error(<span class="hljs-string">'请求异常'</span>);  &#125;);&#125;</code></pre><p>这是一个很常见也很简单的写法，但是当响应码的情况越来越多时会出现代码冗余的缺点；<br>当然这里可以用switch来改写,但是还是不够简洁；<br>所以推荐以下写法，核心思想是利用Object类型的hasOwnProperty()方法。</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> error_code = &#123;    <span class="hljs-string">'00001'</span>: <span class="hljs-string">'报错原因A'</span>,    <span class="hljs-string">'00002'</span>: <span class="hljs-string">'报错原因B'</span>,    <span class="hljs-string">'00003'</span>: <span class="hljs-string">'报错原因C'</span>,    <span class="hljs-string">'00004'</span>: <span class="hljs-string">'报错原因D'</span>,    <span class="hljs-string">'00005'</span>: <span class="hljs-string">'报错原因E'</span>,    <span class="hljs-string">'00006'</span>: <span class="hljs-string">'报错原因F'</span>&#125;<span class="hljs-keyword">this</span>.orderService.getOrder(id)  .subscribe(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;    <span class="hljs-keyword">if</span> (res.code == <span class="hljs-string">'00000'</span>) &#123;      &lt;!-- 响应正确的业务代码 --&gt;    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.error_code.hasOwnProperty(res.code)) &#123;        alert(<span class="hljs-keyword">this</span>.error_code[res.code])    &#125;<span class="hljs-keyword">else</span> &#123;        alert(<span class="hljs-string">"统一通用报错"</span>)    &#125;  &#125;, (error) =&gt; &#123;    <span class="hljs-built_in">console</span>.error(<span class="hljs-string">'请求异常'</span>);  &#125;);&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HTTP缓存代理策略</title>
    <link href="/2019/07/27/HTTP%E7%BC%93%E5%AD%98%E4%BB%A3%E7%90%86%E7%AD%96%E7%95%A5/"/>
    <url>/2019/07/27/HTTP%E7%BC%93%E5%AD%98%E4%BB%A3%E7%90%86%E7%AD%96%E7%95%A5/</url>
    
    <content type="html"><![CDATA[<p>  缓存代理，主要分为两部分，服务端的缓存控制和客户端的缓存控制；客户端的缓存控制由浏览器来实现，而服务端的缓存控制由代理服务器来实现。代理服务器介于浏览器客户端和源服务器之间，相当于一个数据中转站，将未更新可复用的数据缓存起来，以便降低源服务器的并发量。</p><p>服务器端缓存控制策略<br>可以同时控制客户端和代理<br>首先总结一下常用的缓存控制属性的含义：<br>服务器端的Cache-Control主要包括以下属性</p><p>max-age = x 缓存寿命（时间计算从报文创建开始，也就是离开服务器的时间，包含了在链路传输过程中所有节点所停留的时间）<br>s-maxage 只限定在代理上能够存多久，客户端仍然用max-age<br>no_store 禁用缓存<br>no_cache 可以缓存，但使用前必须向服务器验证是否过期<br>must-revalidate 缓存不过期就继续使用，过期了还想使用必须去服务器验证<br>procy-revalidate 只要求代理的缓存过期后必须验证，不必去源服务器验证，只验证到代理环节就行<br>private 缓存只能在客户端保存，任何中间代理都不能缓存<br>public 缓存完全开放，谁都可以存，主要针对代理服务器<br>no-transform 禁止对缓存下来的数据进行优化处理（例如将图片生成png、webp格式等）</p><p><img src="/image/http/01.png" srcset="/img/loading.gif" alt=""></p><p>客户端缓存控制策略<br>关于缓存寿命的两个新属性</p><p>max-stale = x 代理上的缓存过期了也能使用，但是超过x秒就失效<br>min-fresh = x 缓存必须有效且在x秒后仍然有效</p><p><img src="/image/http/02.png" srcset="/img/loading.gif" alt=""></p><p>Chrome下的缓存区别</p><p>Chrome开发者工具Network栏的Size除了资源大小的数值外，还会有from disk cache和form memory cache属性；两者都表示缓存，无需访问服务器。区别在于：<br>from disk cache（存在磁盘中） 浏览器关闭后，数据资源依然存在（一般存储样式css文件）<br>form memory cache（存在内存中） 浏览器关闭后，数据资源被释放掉，不再存在（一半存储脚本字体图片等）</p>]]></content>
    
    
    <categories>
      
      <category>通信</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HTTP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSRF攻击防范</title>
    <link href="/2019/07/24/CSRF%E6%94%BB%E5%87%BB%E9%98%B2%E8%8C%83/"/>
    <url>/2019/07/24/CSRF%E6%94%BB%E5%87%BB%E9%98%B2%E8%8C%83/</url>
    
    <content type="html"><![CDATA[<div class="note note-success">            <p>CSRF（Cross-site request forgery）:跨站请求伪造，是一种挟制用户在当前已登录的Web应用程序上执行非本意的操作的攻击方法。</p>          </div><p>CSRF原理：<br>CSRF攻击思想如下：</p><p><img src="/image/csrf/1.jpg" srcset="/img/loading.gif" alt=""></p><p>引用自<a href="https://www.cnblogs.com/hyddd/archive/2009/04/09/1432744.html" target="_blank" rel="noopener">https://www.cnblogs.com/hyddd/archive/2009/04/09/1432744.html</a></p><p>CSRF攻击成功的两个必要条件<br>1、登录受信任的网站A，且本地存储了Cookie；<br>2、A站点Cookie生效的情况下，访问危险站点B。</p><p>防范方案：<br>在HTTP的 Request Header自定义属性进行验证<br>CSRF的核心是利用浏览器缓存的Cookie，通过图片、广告等各种手段诱导用户去点击一个链接。比如某银行的转账是通过用户访问 <a href="http://bank.test/test?page=10&amp;userID=101&amp;money=10000" target="_blank" rel="noopener">http://bank.test/test?page=10&amp;userID=101&amp;money=10000</a> 页面完成，用户必须先登录bank.test，然后通过点击页面上的按钮来触发转账事件；这里只是举个例子，支付大多还是通过form表单的形式提交。<br>解决方案是当客户端请求服务器时（一般是用户登录的时候），服务器随机生成一个token写入返回的Cookie中，浏览器拿到token之后写入请求头中作为一个自定义参数；这样服务器在接受请求时就会先去校验CSRF-token，如果没有或者不正确都视为伪造请求返回500。</p><p>const headers = new HttpHeaders().set(“X-HD-CSRF”, “CSRF-Token”); </p><p><img src="/image/csrf/2.jpg" srcset="/img/loading.gif" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>安全</category>
      
    </categories>
    
    
    <tags>
      
      <tag>安全</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HTTP实现大文件传输原理</title>
    <link href="/2019/07/16/HTTP%E5%AE%9E%E7%8E%B0%E5%A4%A7%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93%E5%8E%9F%E7%90%86/"/>
    <url>/2019/07/16/HTTP%E5%AE%9E%E7%8E%B0%E5%A4%A7%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>业务背景<br>在编写视频播放功能时，没想明白如何实现大体积视频的一边加载一边播放，这里实际上是利用了HTTP所实现的分块传输，也可以称之为断点续传，下面介绍几个涉及到的关键字段。</p><p>Transfer-Encoding: chunked<br>对于响应报文，存在两种情况：报文长度已知、报文长度未知；这分别对应这响应头里Content-Length、Transfer-Encoding: chunked这两个互斥的字段。<br>Content-Length给出响应报文确切的长度，而Transfer-Encoding: chunked表示报文的body体不是一次性发过来的，而是被分割成多个模块逐个发送。<br>既然是互斥的，也就是说chunked编码是长度未知的，chunked编码在“流式”收发数据时，通常数据是即时生成的（即动态数据），例如压缩下载，是压缩一部分，传输一部分，报文总长度只有全部压缩完才知道。</p><p>分块传输的编码规则有以下四步：<br>1.每个chunk包含长度头和数据块两部分；<br>2.长度头是以 CRLF（回车换行，即\r\n）结尾的一行明文，用 16 进制数字表示长度；<br>3.数据块紧跟在长度头后，最后也用 CRLF 结尾，但数据不包含 CRLF；<br>4.最后用一个长度为 0 的块表示结束，即“0\r\n\r\n”。</p><p>过程如下图：</p><p><img src="/image/http/1.png" srcset="/img/loading.gif" alt=""></p><p>Accept-Ranges: bytes<br>作用就是告诉浏览器，web服务器是支持范围请求的，比如说看视频时跳过片头，或者直接点击到中间部分开始播放，实际上点击之前的chunk就不会被加载了</p><p>Range: bytes=x-y<br>Range是范围请求的专用字段，x和y是以字节为单位的数据范围，e.g<br>“0-” 表示从文档起点到终点，即整个文件；<br>“10-” 表示第10个字节到文档终点；<br>“-1” 表示文档最后一个字节；<br>“-10” 表示文档倒数10个字节</p><p>以下图为例：</p><p><img src="/image/http/2.jpg" srcset="/img/loading.gif" alt=""></p><p>Status Code: 206 Partial Content<br>状态码206与200类似，都表示请求成功，但是body体只是原数据的一部分</p><p>Content-Range: bytes 107413504-330051762/330051763<br>这里描述了该文件片段的起始字节和结束字节以及资源的总大小</p><p>条件请求<br>常用的条件请求有If-Modified-Since和If-None-Match,他们要求服务器在第一次请求的响应报文中提供Last-Modified和ETag；这样第二次请求就可以带上缓存中的值，用来比较资源是否为最新的。如果资源没有变化，则返回304 Not Modified；表示缓存依然有效，浏览器可以更新有效期继续使用。</p><p>Last-Modified: Tue, 26 Mar 2019 07:20:03 GMT<br>标识文件最后修改时间，这样可以用来判断续传文件是否发生过改动</p><p>ETag: “1853a25a02d9ba23f96408d66891ed51”<br>Etag（Entity Tags）主要为了解决 Last-Modified 无法解决的一些问题。<br>1.一些文件可能会周期性的更改，但是内容并不改变（仅改变修改时间），这时候我们并不希望客户端认为这个文件被修改了，而重新 GET；<br>2.某些文件修改非常频繁，例如：在秒以下的时间内进行修改（1s 内修改了 N 次），If-Modified-Since 能检查到的粒度是 s 级的，这种修改客户端无法判断（或者说 UNIX 记录 MTIME 只能精确到秒）。<br>3.某些服务器不能精确的得到文件的最后修改时间。为此，HTTP/1.1 引入了 Etag。Etag 仅仅是一个和文件相关的标记位，需要放在 “” 内，可以是一个版本标记，例如：v1.0.0；也可以是一串编码 “627-4d648041f6b80”；类似于git里打的tag标签。</p>]]></content>
    
    
    <categories>
      
      <category>通信</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HTTP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>通过a标签的download属性+Blob重命名下载文件</title>
    <link href="/2019/07/06/%E9%80%9A%E8%BF%87a%E6%A0%87%E7%AD%BE%E7%9A%84download%E5%B1%9E%E6%80%A7-Blob%E9%87%8D%E5%91%BD%E5%90%8D%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6/"/>
    <url>/2019/07/06/%E9%80%9A%E8%BF%87a%E6%A0%87%E7%AD%BE%E7%9A%84download%E5%B1%9E%E6%80%A7-Blob%E9%87%8D%E5%91%BD%E5%90%8D%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<p>背景：<br>从文件服务器下载文件资源时，通常存储的文件名称都经过二进制转译，导致下载时的文件名为失去语义的二进制字符串。对于定制化的文件服务器可以从后端进行下载重命名，再生成新的下载链接；而对于通用解决方案，可以由前端进行重命名操作。</p><p>解决方案：<br>常用的下载方式：</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> [<span class="hljs-attr">href</span>]=<span class="hljs-string">"download_url"</span> <span class="hljs-attr">target</span>=<span class="hljs-string">"_blank"</span>&gt;</span></code></pre><pre><code class="hljs javascript"><span class="hljs-comment">//或者</span><span class="hljs-built_in">window</span>.location.href = download_url;</code></pre><p>这里采用H5 download属性 + Blob</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"logo.gif"</span> <span class="hljs-attr">download</span>=<span class="hljs-string">"logo.gif"</span>&gt;</span>下载<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></code></pre><p>直接实现下载+重命名操作，但是有缺陷<br>1、不支持IE<br>2、跨域问题<br>如果需要下载的资源是跨域的，包括跨子域，在Chrome浏览器下，使用download属性是可以下载的;但是，并不能重置下载的文件的命名；而FireFox浏览器下，则download属性是无效的，也就是FireFox浏览器无论如何都不支持跨域资源的download属性下载。</p><p>那么为什么要结合Blob?<br>为了支持更多应用场景。<br>如果后端返回文件下载的Url，那么a标签的download可以支持；<br>如果是前端自动生成的动态文件，eg.利用PDF.js将当前页面截图以PDF文件格式进行下载时，或者想要下载页面的文本信息，可以借助Blob转换成二进制文件，作为元素的href属性，配合download属性，实现下载。</p><p>什么是Blob？</p><p>一个Blob对象就是一个包含有只读原始数据的类文件对象。Blob对象中的数据并不一定得是JavaScript中的原生形式。File接口基于Blob, 继承了Blob的功能，并且扩展支持了用户计算机上的本地文件。<br>创建Blob对象的方法有几种，可以调用Blob构造函数，还可以使用一个已有Blob对象上的slice()方法切出另一个Blob对象，还可以调用canvas对象上的toBlob方法。</p><p>表示二进制大对象，常用于文件上传下载，eg.使用Blob从服务器上GET某张图片</p><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> xhr = <span class="hljs-keyword">new</span> XMLHttpRequest();    xhr.open(<span class="hljs-string">"get"</span>, <span class="hljs-string">"pic.jpg"</span>, <span class="hljs-literal">true</span>);xhr.responseType = <span class="hljs-string">"blob"</span>;xhr.onload = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.status == <span class="hljs-number">200</span>) &#123;        <span class="hljs-keyword">var</span> blob = <span class="hljs-keyword">this</span>.response;  <span class="hljs-comment">// this.response也就是请求的返回就是Blob对象</span>        <span class="hljs-keyword">var</span> img = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">"img"</span>);        img.src = <span class="hljs-built_in">window</span>.URL.createObjectURL(blob);        img.onload = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>&#123;            <span class="hljs-built_in">window</span>.URL.revokeObjectURL(img.src); <span class="hljs-comment">// 清除释放</span>        &#125;;        <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'download'</span>).appendChild(img);        &#125;&#125;xhr.send();</code></pre><p>代码：</p><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> funDownload = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">content, filename</span>) </span>&#123;    <span class="hljs-keyword">var</span> url = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">'a'</span>); <span class="hljs-comment">// 创建隐藏的可下载链接</span>    url.download = <span class="hljs-string">'nameYouWant.txt'</span>; <span class="hljs-comment">//格式自定义</span>    url.style.display = <span class="hljs-string">'none'</span>;    <span class="hljs-keyword">var</span> blob = <span class="hljs-keyword">new</span> Blob([content]); <span class="hljs-comment">// 字符内容转变成blob地址</span>    url.href = URL.createObjectURL(blob);    <span class="hljs-built_in">document</span>.body.appendChild(url); <span class="hljs-comment">// 触发点击</span>    url.click();    <span class="hljs-built_in">document</span>.body.removeChild(url); <span class="hljs-comment">// 然后移除</span>&#125;;</code></pre><p>结果：<br>方案最终未被采用，一方面组内规范要求尽量减少DOM操作，二是文件服务器直接面向外界的接口未提供直接面向文件资源的接口，需求废弃。</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HTTP概念性总结</title>
    <link href="/2019/07/02/HTTP%E6%A6%82%E5%BF%B5%E6%80%A7%E6%80%BB%E7%BB%93/"/>
    <url>/2019/07/02/HTTP%E6%A6%82%E5%BF%B5%E6%80%A7%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;工作中几乎每天都在和HTTP协议打交道，但是感觉除了对状态码、请求头、请求体的使用外，对理论及底层协议的了解知之甚少，所有想总结一下HTTP协议的一些概念。</p><div class="note note-success">            <p>HTTP : Hyper Text Transfer Protocal 超文本传输协议</p>          </div><p>首先什么是文本？<br>文本最初指报文、文字，如今发展为文字、图片、音频、视频、压缩包等；</p><p>那么什么是超文本？<br>即文字、图片、音频、视频对混合体，更重要对特点是包含了超链接;最典型的超文本就是HTML，可以以标签形式加载各种超文本资源</p><p>所以HTTP就是：在两点间传输文字、图片、音频、视频等超文本数据的约定和规范。</p><div class="note note-success">            <p>HTTP两个特点：<br>1、双向协议<br>2、允许中转/接力（目的：优化传输过程）</p>          </div><p>CDN<br>优化对途径之一,CDN(Content Delivery Network 内容分发网络)<br>应用了HTTP协议里的缓存和代理技术，代替源站响应客户端的请求。（缓存源站的数据）</p><p>TCP/IP<br>HTTP协议运行在TCP/IP协议之上<br>为什么这么说？<br>因为HTTP（超文本传输协议）中的传输就是依赖于TCP–传输控制协议；<br>而TCP位于IP之上，是基于IP协议提供可靠的（保证数据不丢失）、字节流（保证数据完整）形式的通信</p><p>TCP/IP网络分层模型（四层）<br>应用层<br>传输层（TCP）<br>网际层（IP）<br>链路层</p><p>OSI网络分层模型（七层）–开放式系统互联通信参考模型<br>第一层：物理层，网络的物理形式，例如电缆、光纤、网卡、集线器等等；<br>第二层：数据链路层，它基本相当于 TCP/IP 的链接层；<br>第三层：网络层，相当于 TCP/IP 里的网际层；<br>第四层：传输层，相当于 TCP/IP 里的传输层；<br>第五层：会话层，维护网络中的连接状态，即保持会话和同步；<br>第六层：表示层，把数据转换为合适、可理解的语法和语义；<br>第七层：应用层，面向具体的应用传输数据。</p><p>两个模型的关系（不禁想起大二计算机网络课程死记硬背的日子）</p><p><img src="/image/http/img1.png" srcset="/img/loading.gif" alt=""></p><p>URI<br>统一资源标识符，常见的URL统一资源定位符是它的子集<br>以<a href="http://nginx.org/en/download.html为例" target="_blank" rel="noopener">http://nginx.org/en/download.html为例</a></p><p>URI的三部分包括：<br>1、协议名，指访问资源应当使用的协议，http；<br>2、主机名，指互联网上主机的标记，可以是域名或IP地址，nginx.org；<br>3、路径，资源在主机上的位置，这里是/en/download.html</p><p>HTTPS<br>HTTP over SSL/TLS<br>SSL: Secure Socket Layer，后改名为TLS: Transport Layer Security<br>能够在不安全的环境中为通信的双方创建出一个秘密的、安全的传输通道，实现了加密传输</p><p>最后附上罗剑锋老师–透视HTTP协议上分享的思维导图:</p><p><img src="/image/http/img2.png" srcset="/img/loading.gif" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>通信</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HTTP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>利用postMessage实现跨源通信</title>
    <link href="/2019/05/10/%E5%88%A9%E7%94%A8postMessage%E5%AE%9E%E7%8E%B0%E8%B7%A8%E6%BA%90%E9%80%9A%E4%BF%A1/"/>
    <url>/2019/05/10/%E5%88%A9%E7%94%A8postMessage%E5%AE%9E%E7%8E%B0%E8%B7%A8%E6%BA%90%E9%80%9A%E4%BF%A1/</url>
    
    <content type="html"><![CDATA[<p>一、业务背景：<br>利用OpenCMS构建一个包含公用页头页脚的容器，中间用iframe标签引入Angular页面（我也不想用iframe这种古董，但是解决方案目前只有这个最合适）</p><p>二、引发的问题：<br>众所周知iframe高度自适应问题不是简单一句height:100%就能解决的，尤其是当子页面不断调用接口，页面高度不固定时，需要实时计算子页面的高度。为了解决这个问题，最初我设想的是在父页面通过onload()事件去触发计算iframe高度的方法</p><pre><code class="hljs javascript">ifrme.height = iframe. contentWindow.document.documentElement.scrollHeight</code></pre><p>那么问题来了，onload事件是页面加载完毕触发，可是页面加载完毕时接口调用仍在pending状态，所以并没有取到需要的数据填充到页面中，导致页面高度实际上是远低于实际高度的（因为页面加载了很多图片）。所以我们需要在接口返回之后去触发计算高度这个方法。</p><p>三、关于postMessage：<br>window.postMessage() 方法可以安全地实现跨源通信。<br>postMessage(data,origin)方法接受两个参数；data指要传递的数据，origin为字符串参数，指明目标窗口的源。</p><p>window.postMessage() 方法被调用时，会在所有页面脚本执行完毕之后（e.g., 在该方法之后设置的事件、之前设置的timeout 事件,etc.）向目标窗口派发一个 MessageEvent 消息。 该MessageEvent消息有四个属性需要注意： message 属性表示该message 的类型； data 属性为 window.postMessage 的第一个参数；origin 属性表示调用window.postMessage() 方法时调用页面的当前状态； source 属性记录调用 window.postMessage() 方法的窗口信息。</p><p>然后在父页面全局写入监听方法：</p><pre><code class="hljs javascript"><span class="hljs-built_in">window</span>.addEventListener(e)&#123;     <span class="hljs-keyword">if</span>(e.data == data)&#123;         getIframeHeight();     &#125; &#125;</code></pre><p>这里需要对接受到到MessageEvent对象判断一下消息源，确保监听到到是正确的事件。</p><p>而在Angular代码每一处接口返回成功时，去调用通信方法</p><pre><code class="hljs javascript"><span class="hljs-built_in">window</span>.parent &amp;&amp; <span class="hljs-built_in">window</span>.parent.postMessage(“the data we need”,”https:<span class="hljs-comment">//…….”)</span></code></pre><p>这样就解决了动态刷新iframe页面高度的问题。</p><p>最后的最后，折腾了好久还是废弃了iframe的解决方案，因为在移动端出现了各种意想不到的问题，取而代之的是手写页面去读取远端可配置的数据源；总而言之，今后还是尽量避免iframe的使用，但是不妨碍积累一些使用经验！</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HTML5</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS优化技巧总结</title>
    <link href="/2019/05/03/JS%E4%BC%98%E5%8C%96%E6%8A%80%E5%B7%A7%E6%80%BB%E7%BB%93/"/>
    <url>/2019/05/03/JS%E4%BC%98%E5%8C%96%E6%8A%80%E5%B7%A7%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>1.过滤唯一值<br>ES6 引入了 Set 对象和延展（spread）语法…，我们可以用它们来创建一个只包含唯一值的数组。</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> array = [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">1</span>]<span class="hljs-keyword">const</span> uniqueArray = […<span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>(array)];<span class="hljs-built_in">console</span>.log(uniqueArray); <span class="hljs-comment">// Result: [1, 2, 3, 5]</span></code></pre><p>在 ES6 之前，获得同样的数组需要更多的代码！<br>这个技巧可以支持包含原始类型的数组：undefined、null、boolean、string 和 number。但如果你的数组包含了对象、函数或其他嵌套数组，就不能使用这种方法了。</p><p>2.在循环中缓存数组长度<br>在我们学习使用 for 循环时，一般建议使用这种结构：</p><pre><code class="hljs js"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; array.length; i++)&#123;    <span class="hljs-built_in">console</span>.log(i);&#125;</code></pre><p>在使用这种方式时，for 循环的每次迭代都会重复计算数组长度。<br>有时候这个会很有用，但在大多数情况下，如果能够缓存数组的长度会更好，这样只需要计算一次就够了。我们可以把数组长度复制给一个叫作 length 的变量，例如：</p><pre><code class="hljs js"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, length = array.length; i &lt; length; i++)&#123;    <span class="hljs-built_in">console</span>.log(i);&#125;</code></pre><p>这段代码和上面的差不多，但从性能方面来看，即使数组变得很大，也不需要花费额外的运行时重复计算 array.length。</p><p>3.短路求值<br>使用三元运算符可以很快地写出条件语句，例如：</p><pre><code class="hljs js">x &gt; <span class="hljs-number">100</span> ? ‘Above <span class="hljs-number">100</span>’ : ‘Below <span class="hljs-number">100</span>’;x &gt; <span class="hljs-number">100</span> ? (x &gt; <span class="hljs-number">200</span> ? ‘Above <span class="hljs-number">200</span>’ : ‘Between <span class="hljs-number">100</span><span class="hljs-number">-200</span>’) : ‘Below <span class="hljs-number">100</span>’;</code></pre><p>但有时候三元运算符仍然很复杂，我们可以使用逻辑运算符 &amp;&amp; 和||来替代，让代码更简洁一些。这种技巧通常被称为“短路求值”。<br>假设我们想要返回两个或多个选项中的一个，使用 &amp;&amp; 可以返回第一个 false。如果所有操作数的值都是 true，将返回最后一个表达式的值。</p><pre><code class="hljs js"><span class="hljs-keyword">let</span> one = <span class="hljs-number">1</span>, two = <span class="hljs-number">2</span>, three = <span class="hljs-number">3</span>;<span class="hljs-built_in">console</span>.log(one &amp;&amp; two &amp;&amp; three); <span class="hljs-comment">// Result: 3</span><span class="hljs-built_in">console</span>.log(<span class="hljs-number">0</span> &amp;&amp; <span class="hljs-literal">null</span>); <span class="hljs-comment">// Result: 0</span></code></pre><p>使用||可以返回第一个 true。如果所有操作数的值都是 false，将返回最后一个表达式的值。</p><pre><code class="hljs js"><span class="hljs-keyword">let</span> one = <span class="hljs-number">1</span>, two = <span class="hljs-number">2</span>, three = <span class="hljs-number">3</span>;<span class="hljs-built_in">console</span>.log(one || two || three); <span class="hljs-comment">// Result: 1</span><span class="hljs-built_in">console</span>.log(<span class="hljs-number">0</span> || <span class="hljs-literal">null</span>); <span class="hljs-comment">// Result: null</span></code></pre><p>示例 1<br>假设我们想要返回一个变量的 length，但又不知道变量的类型。<br>我们可以使用 if/else 来检查 foo 是否是一个可接受的类型，但这样会让代码变得很长。这个时候可以使用短路求值：</p><pre><code class="hljs js"><span class="hljs-keyword">return</span> (foo || []).length;</code></pre><p>对于上述两种情况，如果变量 foo 具有 length 属性，这个属性的值将被返回，否则将返回 0。</p><p>示例 2<br>你是否曾经在访问嵌套对象属性时遇到过问题？你可能不知道对象或某个子属性是否存在，所以经常会碰到让你头疼的错误。<br>假设我们想要访问 this.state 中的一个叫作 data 的属性，但 data 却是 undefined 的。在某些情况下调用 this.state.data 会导致 App 无法运行。为了解决这个问题，我们可以使用条件语句：</p><pre><code class="hljs js"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.state.data) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.state.data;&#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-keyword">return</span> ‘Fetching Data’;&#125;</code></pre><p>但这样似乎有点啰嗦，而||提供了更简洁的解决方案：</p><pre><code class="hljs js"><span class="hljs-keyword">return</span> (<span class="hljs-keyword">this</span>.state.data || ‘Fetching Data’);</code></pre><p>4.转换成布尔值<br>除了标准的布尔值 true 和 false，在 JavaScript 中，所有的值要么是“真值”要么是“假值”。<br>在 JavaScript 中，除了 0、“”、null、undefined、NaN 和 false 是假值之外，其他的都是真值。<br>我们可以使用! 云算法来切换 true 和 false。</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> isTrue = !<span class="hljs-number">0</span>;<span class="hljs-keyword">const</span> isFalse = !<span class="hljs-number">1</span>;<span class="hljs-keyword">const</span> alsoFalse = !!<span class="hljs-number">0</span>;<span class="hljs-built_in">console</span>.log(<span class="hljs-literal">true</span>); <span class="hljs-comment">// Result: true</span><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> <span class="hljs-literal">true</span>); <span class="hljs-comment">// Result: “boolean”</span></code></pre><p>5.转换成字符串<br>要快速将数字转换成字符串，我们可以使用 + 运算符，然后在后面跟上一个空字符串。</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> val = <span class="hljs-number">1</span> + “”;<span class="hljs-built_in">console</span>.log(val); <span class="hljs-comment">// Result: “1”</span><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> val); <span class="hljs-comment">// Result: “string”</span></code></pre><p>6.转换成数字<br>要把字符串转成数字，也可以使用 + 运算符。</p><pre><code class="hljs js"><span class="hljs-keyword">let</span> int = “<span class="hljs-number">15</span>”;int = +int;<span class="hljs-built_in">console</span>.log(int); <span class="hljs-comment">// Result: 15</span><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> int); Result: “number”</code></pre><p>也可以使用这种方式将布尔值转成数字，例如：</p><pre><code class="hljs js"><span class="hljs-built_in">console</span>.log(+<span class="hljs-literal">true</span>); <span class="hljs-comment">// Return: 1</span><span class="hljs-built_in">console</span>.log(+<span class="hljs-literal">false</span>); <span class="hljs-comment">// Return: 0</span></code></pre><p>在某些情况下，+ 运算符会被解析成连接操作，而不是加法操作。对于这种情况，可以使用两个波浪号：<del>。<br>一个波浪号表示按位取反操作，例如，</del>15 等于 -16。</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> int = “<span class="hljs-number">15</span>”<span class="hljs-built_in">console</span>.log(int); <span class="hljs-comment">// Result: 15</span><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> int); Result: “number”</code></pre><p>使用两个波浪号可以再次取反，因为 -(-n-1)=n+1-1=n，所以-16 等于 15。</p><p>7.快速幂运算<br>从 ES7 开始，可以使用 ** 进行幂运算，比使用 Math.power(2,3) 要快得多。</p><pre><code class="hljs js"><span class="hljs-built_in">console</span>.log(<span class="hljs-number">2</span> ** <span class="hljs-number">3</span>); <span class="hljs-comment">// Result: 8</span></code></pre><p>但要注意不要把这个运算符于 ^ 混淆在一起了，^ 通常用来表示指数运算，但在 JavaScript 中，^ 表示位异或运算。<br>在 ES7 之前，可以使用位左移运算符&lt;&lt;来表示以 2 为底的幂运算：</p><pre><code class="hljs js"><span class="hljs-comment">// 以下表达式是等效的:</span><span class="hljs-built_in">Math</span>.pow(<span class="hljs-number">2</span>, n);<span class="hljs-number">2</span> &lt;&lt; (n - <span class="hljs-number">1</span>);<span class="hljs-number">2</span>*n;</code></pre><p>例如，2 &lt;&lt; 3 = 16 等同于 2 * 4 = 16。</p><p>8.快速取整<br>我们可以使用 Math.floor()、Math.ceil() 或 Math.round() 将浮点数转换成整数，但有另一种更快的方式，即使用位或运算符 |。</p><pre><code class="hljs js"><span class="hljs-built_in">console</span>.log(<span class="hljs-number">23.9</span> | <span class="hljs-number">0</span>); <span class="hljs-comment">// Result: 23</span><span class="hljs-built_in">console</span>.log(<span class="hljs-number">-23.9</span> | <span class="hljs-number">0</span>); <span class="hljs-comment">// Result: -23</span></code></pre><p>| 的实际行为取决于操作数是正数还是负数，所以在使用这个运算符时要确保你知道操作数是正是负。<br>如果 n 是正数，那么 n|0 向下取整，否则就是向上取整。它会移除小数部分，也可以使用~~ 达到同样的效果。<br>移除整数尾部数字<br>| 运算符也可以用来移除整数的尾部数字，这样就不需要像下面这样：</p><pre><code class="hljs js"><span class="hljs-keyword">let</span> str = “<span class="hljs-number">1553</span>”;<span class="hljs-built_in">Number</span>(str.substring(<span class="hljs-number">0</span>, str.length - <span class="hljs-number">1</span>));</code></pre><p>相反，我们可以这样：</p><pre><code class="hljs js"><span class="hljs-built_in">console</span>.log(<span class="hljs-number">1553</span> / <span class="hljs-number">10</span> | <span class="hljs-number">0</span>) <span class="hljs-comment">// Result: 155</span><span class="hljs-built_in">console</span>.log(<span class="hljs-number">1553</span> / <span class="hljs-number">100</span> | <span class="hljs-number">0</span>) <span class="hljs-comment">// Result: 15</span><span class="hljs-built_in">console</span>.log(<span class="hljs-number">1553</span> / <span class="hljs-number">1000</span> | <span class="hljs-number">0</span>) <span class="hljs-comment">// Result: 1</span></code></pre><p>9.自动类绑定<br>在 ES6 中，我们可以使用箭头进行隐式绑定，这样可以为类的构造器省下一些代码，并跟一些重复出现的表达式说再见，比如 this.myMethod = this.myMethod.bind(this)。</p><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; React, Component &#125; <span class="hljs-keyword">from</span> React;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Compononent</span> </span>&#123;    <span class="hljs-keyword">constructor</span>(props) &#123;        <span class="hljs-keyword">super</span>(props);        <span class="hljs-keyword">this</span>.state = &#123;&#125;;    &#125;     myMethod = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;        <span class="hljs-comment">// This method is bound implicitly! </span>        render() &#123;            <span class="hljs-keyword">return</span> (                &lt;div&gt;                    &#123;<span class="hljs-keyword">this</span>.myMethod()&#125;                &lt;<span class="hljs-regexp">/div&gt;</span><span class="hljs-regexp">            ) </span><span class="hljs-regexp">        &#125;</span><span class="hljs-regexp">    &#125;</span><span class="hljs-regexp">&#125;</span></code></pre><p>10.截取数组<br>如果你想从一个数组尾部移除某些元素，可以使用一种比 splice() 更快的方法。<br>例如，如果你知道初始数组的大小，可以像下面这样重新定义它的 length 属性：</p><pre><code class="hljs js"><span class="hljs-keyword">let</span> array = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>];array.length = <span class="hljs-number">4</span>;<span class="hljs-built_in">console</span>.log(array); <span class="hljs-comment">// Result: [0, 1, 2, 3]</span></code></pre><p>这显然是一种更简洁的解决方案。不过，我发现 slice() 的运行速度更快，所以，如果你更看重速度，可以像下面这样：</p><pre><code class="hljs js"><span class="hljs-keyword">let</span> array = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>];array = array.slice(<span class="hljs-number">0</span>, <span class="hljs-number">4</span>);<span class="hljs-built_in">console</span>.log(array); <span class="hljs-comment">// Result: [0, 1, 2, 3]</span></code></pre><p>11.获取数组最后的元素<br>数组的 slice() 方法可以接受负整数，并从数组的尾部开始获取元素。</p><pre><code class="hljs js"><span class="hljs-keyword">let</span> array = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>];<span class="hljs-built_in">console</span>.log(array.slice(<span class="hljs-number">-1</span>)); <span class="hljs-comment">// Result: [9]</span><span class="hljs-built_in">console</span>.log(array.slice(<span class="hljs-number">-2</span>)); <span class="hljs-comment">// Result: [8, 9]</span><span class="hljs-built_in">console</span>.log(array.slice(<span class="hljs-number">-3</span>)); <span class="hljs-comment">// Result: [7, 8, 9]</span></code></pre><p>12.格式化 JSON<br>你之前可能使用过 JSON.stringify，但你是否知道它还可以用来给 JSON 添加缩进？<br>stringify() 方法可以接受两个额外的参数，一个是函数（形参为 replacer），用于过滤要显示的 JSON，另一个是空格个数（形参为 space）。</p><p>space 可以是一个整数，表示空格的个数，也可以是一个字符串（比如’\t’表示制表符），这样得到的 JSON 更容易阅读。</p><pre><code class="hljs js"><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">JSON</span>.stringify(&#123; <span class="hljs-attr">alpha</span>: ‘A’, <span class="hljs-attr">beta</span>: ‘B’ &#125;, <span class="hljs-literal">null</span>, ‘\t’));<span class="hljs-comment">// Result:</span><span class="hljs-comment">// ‘&#123;</span><span class="hljs-comment">// “alpha”: A,</span><span class="hljs-comment">// “beta”: B</span><span class="hljs-comment">// &#125;’</span></code></pre><p>总结：<br>js的优化是一个循环往复的过程，通过不断的优化可以大幅减少冗余代码</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS事件冒泡及阻止</title>
    <link href="/2019/04/25/JS%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1%E5%8F%8A%E9%98%BB%E6%AD%A2/"/>
    <url>/2019/04/25/JS%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1%E5%8F%8A%E9%98%BB%E6%AD%A2/</url>
    
    <content type="html"><![CDATA[<div class="note note-success">            <p>事件冒泡 ：当一个元素接收到事件的时候 会把他接收到的事件传给自己的父级，一直到window 。（注意这里传递的仅仅是事件 并不传递所绑定的事件函数；所以如果父级没有绑定事件函数，就算传递了事件 也不会有什么表现 但事件确实传递了）</p>          </div><p>举个例子，先点击一下父级按钮再点击一下子级按钮，可以发现click事件也被冒泡传递到了它的父级</p><p><img src="/image/event_bubbling/img1.png" srcset="/img/loading.gif" alt=""></p><p>避免冒泡事件的方法是event.stopPropagation()方法，同上的例子</p><p><img src="/image/event_bubbling/img2.png" srcset="/img/loading.gif" alt=""></p><p>类似的问题，阻止默认事件的发生可以采用event.preventDefault()方法，例如a标签在点击后不发生跳转。</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Angular生命周期钩子</title>
    <link href="/2019/04/25/Angular%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90/"/>
    <url>/2019/04/25/Angular%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90/</url>
    
    <content type="html"><![CDATA[<p>1.ngOnChanges<br>当 Angular（重新）设置数据绑定输入属性时响应。 该方法接受当前和上一属性值的 SimpleChanges 对象。<br>在 ngOnInit() 之前以及所绑定的一个或多个输入属性的值发生变化时都会调用。</p><p>2.ngOnInit<br>在 Angular 第一次显示数据绑定和设置指令/组件的输入属性之后，初始化指令/组件。<br>在第一轮 ngOnChanges() 完成之后调用，只调用一次。</p><p>3.ngDoCheck<br>检测，并在发生 Angular 无法或不愿意自己检测的变化时作出反应。<br>在每个变更检测周期中，紧跟在 ngOnChanges() 和 ngOnInit() 后面调用。</p><p>4.ngAfterContentInit<br>每当 Angular 把外部内容投影进组件/指令的视图之后调用。<br>第一次 ngDoCheck() 之后调用，只调用一次。</p><p>5.ngAfterContentChecked<br>每当 Angular 完成被投影组件内容的变更检测之后调用。<br>ngAfterContentInit() 和每次 ngDoCheck() 之后调用。</p><p>6.ngAfterViewInit<br>每当 Angular 初始化完组件视图及其子视图之后调用。<br>第一次 ngAfterContentChecked() 之后调用，只调用一次。</p><p>7.ngAfterViewChecked<br>每当 Angular 做完组件视图和子视图的变更检测之后调用。<br>ngAfterViewInit() 和每次 ngAfterContentChecked() 之后调用。</p><p>8.ngOnDestroy<br>当 Angular 每次销毁指令/组件之前调用并清扫。 在这儿反订阅可观察对象和分离事件处理器，以防内存泄漏。<br>在 Angular 销毁指令/组件之前调用。</p><p><img src="/image/angular/img1.jpg" srcset="/img/loading.gif" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Angular</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>getClientRects() 和 getBoundingClientRect()的区别</title>
    <link href="/2019/04/02/getClientRects-%E5%92%8C-getBoundingClientRect-%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2019/04/02/getClientRects-%E5%92%8C-getBoundingClientRect-%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;简单来说，getClientRects返回的其实是个数组，数组中有很多个类似getBoundingClientRect返回的对象(这样的对象称为TextRectangleList)。getBoundingClientRect返回的永远是最外框框的那个矩形区域相关的坐标偏移对象；而getClientRects是多行文字区域的坐标偏移集合。</p><p>例如：</p><p><img src="/image/getClientRects/img1.jpg" srcset="/img/loading.gif" alt=""></p><p>结果为：</p><p><img src="/image/getClientRects/img2.jpg" srcset="/img/loading.gif" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常用的CSS3新特性</title>
    <link href="/2019/03/31/%E5%B8%B8%E7%94%A8%E7%9A%84CSS3%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <url>/2019/03/31/%E5%B8%B8%E7%94%A8%E7%9A%84CSS3%E6%96%B0%E7%89%B9%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<p>圆角<br>1.border-radius 圆角边框<br>2.box-shadow 阴影框<br>3.border-image （不支持ie）边界图片</p><p>背景<br>1.background-image<br>2.background-size<br>3.background-origin 指定背景图片的位置区域（border-box, padding-box, content-box）<br>4.background-clip 背景剪裁（指从指定位置开始绘制）</p><p>渐变（gradients）<br>1.linear-gradient 线性 background: linear-gradient(direction,color-stop1,color-stop2,..)<br>其中参数direction包括预定义的：to bottom、to top、 to right等，也可以使用角度angle；<br>0deg 从下到上、90deg 从左到右；<br>2.radial-gradient 径向 background: radial-gradient(center,shape,size,start-color,…,last-color)<br>shape参数：circle、ellipse等；<br>size参数定义渐变大小：closest-side、farthest-side、closest-corner、farthest-corner(默认)<br>3.repeating-linear-gradient(red,yellow 10%,green 20%) 重复线性渐变</p><p>透明度（transparency）<br>rgba()最后一个参数0～1</p><p>文本效果<br>1.text-shadow<br>2.box-shadow<br>3.text-overflow 属性值包括：clip(修建文本)、ellipsis(显示省略号)<br>4.word-wrap<br>5.word-break 自动换行：break-all(允许在单词内换行)、keep-all(只能在半角空格或连字符处换行)</p><p>2D转换<br>1.translate() x,y平移<br>2.rotate() xdeg顺时针旋转<br>3.scale() x,y 增大／减小<br>4.skew() xdeg,ydeg 倾斜坐标系<br>5.matrix() 表示矩阵，需要六个参数</p><p>matrix() 方法把所有 2D 转换方法组合在一起。<br>matrix() 方法需要六个参数，包含数学函数，允许：旋转、缩放、移动以及倾斜元素。<br>matrix()中的6个参数代表了一个3*3的矩阵（线性代数）。</p><p>平移<br>在CSS3中我们矩阵的原始值是这样的<br>transforms:matrix(1,0,0,1,0,0);<br>写成我们数学里矩阵的形式是这样的</p><p><img src="/image/css3_feature/img1.png" srcset="/img/loading.gif" alt=""></p><p>这么看起来，我们不太好分辨哪个数字对应的是我们上面写的matrix值里的哪一个，那为了便于描述我们把它写成：<br>transforms:matrix(a,b,c,d,e,f);<br>那么写成数学矩阵式就是这样的：</p><p><img src="/image/css3_feature/img2.png" srcset="/img/loading.gif" alt=""></p><p>根据我们上面说的用矩阵与向量的乘法来施加运动，我们就可以来看一下它到底是怎么运动起来的</p><p><img src="/image/css3_feature/img3.png" srcset="/img/loading.gif" alt=""></p><p>这么一来我们可以得到一个式子就是：<br>x’=ax+cy+e<br>y’=bx+dy+f</p><p>x’和y’就是我们变换后的水平位置坐标和垂直位置坐标，现在我们想要把元素往x轴的正方向平移10，在y轴方向上不动,反映到方程式里，我们要怎么来实现呢</p><p>元素往x轴的正方形平移10，在y轴方向上不动，反映到方程式里：</p><p>x’=ax+cy+e —（x’=ax+cy+e+10)</p><p>y’=bx+dy+f （不变）</p><p>元素往y轴的正方向平移10，在x轴方向上不动，反映到方程式里：</p><p>x’=ax+cy+e （不变）</p><p>y’=bx+dy+f —（y’=bx+dy+f+10）</p><p>元素同时往x轴正向和y轴正向移动10个单位 ：</p><p>我们用css矩阵来写：transform： matrix（1,0,0,1,10,10）–其他数值都不动，e和f分别加10</p><p>结论：平移只有跟e和f有关系，跟其他a,b,c,d没有关系，它们该怎么样还是怎么样，e对应x轴的平移，f对应y轴的平移，往正方向平移多少单位就加上多少单位，反之则减去多少个单位。</p><p>缩放<br>平移就是x或者y加减一个常数来得到的，理解了平移之后缩放就很简单了，可不就是x和y的倍数发生了变化么，反映到式子上来那就是系数的变化，那同样道理我们把上面的式子拿过来</p><p>x放大2倍 y不变</p><p>x’=ax+cy+e—（x’=2ax+cy+e) 就是x的系数增大2倍</p><p>y’=bx+dy+f (不变)</p><p>y放大2倍 x不变</p><p>x’=ax+cy+e (不变)</p><p>y’=bx+dy+f—(y’=bx+2dy+f)</p><p>就是y的系数增大2倍x和y都放大2倍，就是x和y的系数都增大2倍写成矩阵就是：</p><p>transform：matrix（2,0,0,2,0,0)</p><p>结论：缩放只有跟a和b有关系，跟其他数值都无关，a对应x轴缩放，b对应y轴缩放，缩放多少倍就乘以多少</p><p>旋转<br>相比于平移和缩放，旋转相对来说要复杂点了，当然搞清楚了就没什么难的了</p><p>transform：matrix（cosθ，-sinθ,sinθ,cosθ,0,0);</p><p><img src="/image/css3_feature/img4.png" srcset="/img/loading.gif" alt=""></p><p>现在我们要让这个元素往顺时针方向旋转45°（sin45°=0.707，cos45°=0.707），那么我们给div加样式如下：</p><p>transform: matrix(0.707,0.707,-0.707,0.707,0,0);</p><p><img src="/image/css3_feature/img5.png" srcset="/img/loading.gif" alt=""></p><p>这个div是不是就按我们预期的一样往顺时针方向转了45°了；</p><p>接下来我们把这个旋转放到数学里来看下<br>那同样的我们把它写成数学里矩阵的形式：</p><p><img src="/image/css3_feature/img6.png" srcset="/img/loading.gif" alt=""></p><p>同样的根据矩阵的计算公式，我们可以得到公式：</p><p>x’=xcosθ-ysinθ; y’=xsinθ+ycosθ</p><p>现在我们先把公式放在这里，我们来看一下下图的这个正方形，从图中我们可以知道a,b,c,d的坐标分别为：</p><p>A(0,1) B(1,1) C(1,0) D(0,0)</p><p>当我们让它旋转90°之后，那此时的cos45°就是0 sin45°都为1，分别把A,B,C,D里的x,y代入上面的公式之后我们可以得到：</p><p>现在这个正方形就变成了下图的样子，和我们写代码达到的效果是一样的：</p><p><img src="/image/css3_feature/img7.png" srcset="/img/loading.gif" alt=""></p><p>结论：我们要记住初始写法是这样的<br>transform：matrix（cosθ，-sinθ,sinθ,cosθ,0,0);然后需要旋转多少度就计算出这个度数的cosθ，sinθ就可以达到我们想要的效果</p><p>3D转换<br>1.translate3d(x,y,z)<br>2.scale3d(x,y,z)<br>3.rotate3d(x,y,z,angle)</p><p>过渡<br>transition:width 2s,height 2s,transform 2s;</p><p>动画 @Keyframes规则、animation属性</p><pre><code>@Keyframes mymove{     from {top:0px;}    to {top:200px;}}</code></pre><p>div</p><pre><code>{     animation:mymove 5s infinite;    -webkit-animation:mymove 5s infinite; /* Safari 和 Chrome */}</code></pre><p>多列<br>1.column-count 指定元素的列数<br>2.column-gap xpx 指定列之间的距离<br>3.column-rule 设置列之间的宽度、样式、颜色<br>4.column-rule-color<br>5.column-rule-style<br>6.column-rule-width<br>7.column-width</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript原型</title>
    <link href="/2019/03/03/JavaScript%E5%8E%9F%E5%9E%8B/"/>
    <url>/2019/03/03/JavaScript%E5%8E%9F%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<p>一、JavaScript 的原型：<br>1、如果所有对象都有私有字段[[prototype]]，就是对象都原型；<br>2、读一个属性，如果对象本身没有，则会继续访问对象的原型，直到原型为空或者找到为止。</p><p>二、ES6提供了三个直接访问操作原型的方法<br>1、Object.create 根据指定的原型创建新对象，原型可以是null;<br>2、Object.getPrototypeOf 获取一个对象的原型；<br>3、Object.setPrototypeOf 设置一个对象的原型。</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS规则</title>
    <link href="/2019/03/03/CSS%E8%A7%84%E5%88%99/"/>
    <url>/2019/03/03/CSS%E8%A7%84%E5%88%99/</url>
    
    <content type="html"><![CDATA[<p>@规则<br>1.@charset<br>用于提示CSS文件使用的字符编码方式，必须出现在最前面</p><pre><code>@charset “utf-8”</code></pre><p>2.@import<br>用于引入一个CSS文件，除了@charset规则不会被引入，其他文件的全部内容都能被引入</p><p>3.@media<br>对设备类型进行判断</p><p>4.@page<br>用于分页媒体访问网页时的表现设置</p><pre><code>@page {    size:8.5in 11in;    margin:10%;    @top-left {        content: “Hamlet”;    }    @top-right {        content: “Page” counter(page);    }}</code></pre><p>5.@counte-style<br>产生一种数据，用于定义列表项的表现</p><p>6.@key-frames<br>产生一种数据，用于定义动画关键帧</p><p>7.@fontface<br>用于定义一种字体， icon font技术就是利用这个特性来实现的</p><p>8.support<br>检查环境的特性，与media类似</p><p>9.@namespace<br>用于跟XML命名空间配合的一个规则，表示内部的CSS选择器全都带上特定命名空间</p><p>10.viewport<br>用于设置视口的一些特性，不过兼容性目前不是很好，多数时候被html的meta代替</p><p>普通规则<br>分为两块：选择器、声明列表（分为属性和值（值的类型、函数））</p><p>CSS支持的计算型函数（仅举例）<br>1、calc()支持加减乘除四则运算<br>针对纬度进行计算时，允许不同单位混合运算</p><pre><code>width：calc(100%/3 - 21rem -21px);</code></pre><p>2、max()</p><p>3、min()</p><p>4、clamp()<br>给一个值限定一个范围，超出范围外则使用范围的最大值或最小值</p><p>5、toggle()<br>在规则选中多个元素时生效，它会在几个值之间来回切换<br>例如想让一个列表项的样式圆点和方点间隔出现，可以使用</p><pre><code>ul { list-style-type: toggle( circle, square); }</code></pre><p>6、attr()<br>允许CSS接受属性值（html的属性值）的控制</p><p>后期查阅整理后，按功能分为5个类别</p><p>图片</p><pre><code>filterblur()brightness()contrast()drop-shadow()grayscale()hue_rotate()invert()opacity()saturate()sepia()cross-fade()element()image-set()imagefunction()</code></pre><p>图形绘制</p><pre><code>conic-gradient()linear-gradient()radial-gradient()repeating-linear-gradient()repeating-radial-gradient()shape()</code></pre><p>布局</p><pre><code>calc()clamp()fit-content()max()min()minmax()repeat()</code></pre><p>变形/动画</p><pre><code>transformmatrix()matrix3d()perspective()rotate()rotate3d()rotateX()rotateY()rotateZ()scale()scale3d()scaleX()scaleY()scaleZ()skew()skewX()skewY()translate()translate3d()translateX()translateY()translateZ()</code></pre><p>环境与元素</p><pre><code>var()env()attr()</code></pre>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>i标签的使用</title>
    <link href="/2019/01/24/i%E6%A0%87%E7%AD%BE%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2019/01/24/i%E6%A0%87%E7%AD%BE%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;问题：使用i标签引入小图标如箭头、☑️ 等icon时不显示图标；</p><div class="note note-success">            <p>i标签是行内元素，行内元素定义宽高是无效的，类比用a标签做button时定义宽高无效；需要设置display = block或者inline-block转化为块级元素才有效。</p>          </div><p>&emsp;&emsp;此外，对于行内元素，margin上下对其无效（左右有效）；而padding上下虽然有效，但是会覆盖上下的相邻元素而不是撑开，即不会影响其他行的位置；所以对于行内元素要避免使用margin-top、margin-bottom、padding-top、padding-bottom。</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS蒙层效果</title>
    <link href="/2018/12/01/CSS%E8%92%99%E5%B1%82%E6%95%88%E6%9E%9C/"/>
    <url>/2018/12/01/CSS%E8%92%99%E5%B1%82%E6%95%88%E6%9E%9C/</url>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;今天在制作高保真视觉效果图的时候，遇到一个这样的需求：在一张图片的上层加了一层灰色的蒙板，使得整个图片达到变暗的效果。第一时间的想法就是现设置</p><pre><code>background: gray url(…) no-repeat;</code></pre><p>然而这样达到的效果仅仅是图片覆盖背景色，并不能让他们重合。后来了解到了background-blend-mode 属性，他定义了背景层的混合模式（图片与颜色）。</p><pre><code>background-color: darkgrey; background-blend-mode: multiply; background-image: url(“img/img1.png”);</code></pre><p>&emsp;&emsp;当设置属性值为multiply时，为正片叠底模式，如果是两张重叠的图片，将会重合显示而不是覆盖。这样暂时性的实现了所需要的视觉效果，然而我缺忽略了蒙板所实现的功能并不是让图片变暗，而是在hover的时候将蒙板撤去达到变亮的效果，所以最后的实现方式是在图片上层用绝对定位覆盖一个设置透明度的灰色区域，当hover时，该区域display:none;其中覆盖的模板应设为:</p><pre><code>position: absolute; top: 0; left: 0;</code></pre><p>且宽高与图片保持一致。</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
